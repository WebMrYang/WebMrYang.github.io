{"./":{"url":"./","title":"首页","keywords":"","body":"Introduction 换一台电脑打开GitBook项目居然运行不了，gitbook serve和gitbook build都报错。 Error: ENOENT: no such file or directory, stat ‘C:*demo_book_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js’ 原来是一个Bug（Vesion：3.2.3）。 https://github.com/GitbookIO/gitbook/issues/1309 解决办法如下。 用户目录下找到以下文件。 .gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js Replace all confirm: true with confirm: false gitbook fetch 2.6.7 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/updateRecord.html":{"url":"gitbook/updateRecord.html","title":"更新记录","keywords":"","body":"更新记录 换一台电脑打开GitBook项目居然运行不了，gitbook serve和gitbook build都报错。 Error: ENOENT: no such file or directory, stat ‘C:*demo_book_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js’ 原来是一个Bug（Vesion：3.2.3）。 https://github.com/GitbookIO/gitbook/issues/1309 解决办法如下。 用户目录下找到以下文件。 .gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js Replace all confirm: true with confirm: false gitbook fetch 2.6.7 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/meun.html":{"url":"gitbook/meun.html","title":"文档库目录","keywords":"","body":"文档库目录 首页 更新记录 文档库目录 留言板 CSS JavaScript Regular Node Mysql 其他资料库 Markdown_Website Markdown GitBook 建站 环境搭建 插件 发布 开发问题记录 GitHub 发布 SSH Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-26 16:06:36 "},"gitbook/messageBoard.html":{"url":"gitbook/messageBoard.html","title":"留言板","keywords":"","body":"留言板 使用gitalk来进行留言 var gitalk = new Gitalk({ \"clientID\": \"8c2f22bd64d1ea012ac5\", \"clientSecret\": \"992cdea444e1503ceac91bfd74907b37e590a159\", \"repo\": \"webmryang.github.io\", \"owner\": \"WebMrYang\", \"admin\": [\"WebMrYang\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-25 16:50:11 "},"gitbook/CSS-library/":{"url":"gitbook/CSS-library/","title":"CSS","keywords":"","body":"CSS Mysql-library Transitions, Transforms和Animation Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 15:17:41 "},"gitbook/CSS-library/Flex.html":{"url":"gitbook/CSS-library/Flex.html","title":"Flex","keywords":"","body":"一、Flex布局是什么？ Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局（行内元素也可以）。 二、基本概念 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目” 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性 以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性 flex-direction属性决定主轴的方向（即项目的排列方向）。 .box { flex-direction: row | row-reverse | column | column-reverse;} 3.2 flex-wrap属性 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse;} 3.3 flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: row nowrap ;} 3.4 justify-content属性 justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around;} 3.5 align-items属性 align-items属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch;} 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} 四、项目的属性 以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: ;} 4.2 flex-grow属性 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 .item { flex-grow: ; /* default 0 */} 4.3 flex-shrink属性 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 .item { flex-shrink: ; /* default 1 */} 4.4 flex-basis属性 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: | auto; /* default auto */} 4.5 flex属性 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ ? || ]} 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch;} 五、尝试 Document * { border: 0px; padding: 0px; margin: 0px; } .main { display: flex; height: 100vh; /* flex-direction: row; flex-wrap: wrap-reverse; */ flex-flow: row wrap-reverse; /* flex-flow: row nowrap; align-items: center ; */ justify-content: space-around; align-content: center; } .main div:first-child, .main div:last-child { height: 100px; } .main div { height: 200px; width: 100px; border: 1px solid red; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 15:42:09 "},"gitbook/CSS-library/BoxCenter.html":{"url":"gitbook/CSS-library/BoxCenter.html","title":"居中效果","keywords":"","body":"一、 圣杯 代码 css: #hd{ height:50px; background: #666; text-align: center; } #bd{ /*左右栏通过添加负的margin放到正确的位置了，此段代码是为了摆正中间栏的位置*/ padding:0 200px 0 180px; height:100px; } #middle{ float:left; width:100%;/*左栏上去到第一行*/ height:100px; background:blue; } #left{ width:180px; height:100px; background:#0c9; float:left; margin-left:-100%; /*中间栏的位置摆正之后，左栏的位置也相应右移，通过相对定位的left恢复到正确位置*/ position:relative; left:-180px; } #right{ width:200px; height:100px; background:#0c9; float:left; margin-left:-200px; /*中间栏的位置摆正之后，右栏的位置也相应左移，通过相对定位的right恢复到正确位置*/ position:relative; right:-200px; } #footer{ height:50px; background: #666; text-align: center; } html: header middle left right footer 二、双飞翼 #hd{ height:50px; background: #666; text-align: center; } #middle{ float:left; width:100%;/*左栏上去到第一行*/ height:100px; background:blue; } #left{ width:180px; height:100px; background:#0c9; float:left; margin-left:-100%; } #right{ width:200px; height:100px; background:#0c9; float:left; margin-left:-200px; } /*给内部div添加margin，把内容放到中间栏，其实整个背景还是100%*/ #inside{ margin:0 200px 0 180px; height:100px; } #footer{ clear:both; /*记得清楚浮动*/ height:50px; background: #666; text-align: center; } html: middle left right 三、区别： 了解margin和padding和position三者区别,并且对于页面具备的影响margin的100%（父元素的width）以父级为参考,如果没有父级则为body体元,position不能使得元素换行，只能在同行显示，而margin和padding确可以使得元素换行 主要是圣杯的需要把三个标签都包含，而双飞翼确不需要 圣杯需要定位，而双飞翼不需要 圣杯（主要是margin出现问题）在页面大小切换下会出现样式问题，而双飞翼确不会，只是会使得页面中间的contern越来越小（大） 四、flex布局居中 只要是使用 * { margin: 0px; border: 0px; padding: 0px; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } .box { height: 200px; width: 200px; background: yellow; } 五、定位居中 .box { height: 200px; width: 200px; position: absolute; left: 50%; top: 50%; background: yellow; transform: translate(-50%, -50%); } Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 15:47:27 "},"gitbook/CSS-library/Animation.html":{"url":"gitbook/CSS-library/Animation.html","title":"动画animation","keywords":"","body":"CSS3动画属性的区别（Transitions, Transforms和Animation） 1. 介绍 CSS3动画相关的几个属性是：transition, transform, animation；我分别理解为过渡，变换，动画。虽意义相近，但具体角色不一。 transition指过渡啦，就是从a点都b点，就像过江坐渡轮，是有时间的，是连续的，一般针对常规CSS属性；transform指变换，就那几个固定的属性：旋转啦，缩放啦，偏移啦什么的，当独立于远房亲戚transition独自使用时，效果就是很干涩机械的旋转移动。要是配合transition属性，旋转啊什么的，就会很平滑。animation最先安家于Safari浏览器，自成一家，与transition和transform有老死不相往来之感，但是要说单挑的话，animation要比transition厉害些。 2.详情 2.1 transition 其作用是：平滑的改变CSS的值。无论是点击事件，焦点事件，还是鼠标hover，只要值改变了，就是平滑的，就是动画。于是乎，只要一个整站通用的class，就可以很轻松的渐进增强地实现动画效果，超有实用价值的说。 transiton属性是下面几个属性的缩写： transition-property 指定过渡的属性值，比如transition-property:opacity就是只指定opacity属性参与这个过渡。 transition-duration 指定这个过渡的持续时间 transition-delay 延迟过渡时间 transition-timing-function 指定过渡动画缓动类型，有ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(),其中，linear线性过度，ease-in由慢到快，ease-out由快到慢，ease-in-out由慢到快在到慢 例如下面这个很简单的例子： button { background: palegreen; border: none; outline: none; width: 100px; height: 30px; cursor: pointer; position: relative; z-index: 1; } button::before { content: ''; position: absolute; z-index: -1; top: 0; bottom: 0; left: 0; right: 0; height: 0; background: red; transform-origin: center bottom; transition: transform 0.4s ease-in-out; } button:hover::before { height: 100%; transform-origin: center top; } 查看 2.2 transform transform指变换，使用过photoshop的人应该知道里面的Ctrl+T自由变换。transform就是指的这个东西，拉伸，压缩，旋转，偏移。见下面示例代码： .trans_skew { transform: skew(35deg); } .trans_scale { transform:scale(1, 0.5); } .trans_rotate { transform:rotate(45deg); } .trans_translate { transform:translate(10px, 20px); } transform属性要是加上transition的过渡特性，那可就是如虎添翼，可以产生不少美妙的火花，例如下面这个例子，关键代码如下： .trans_effect { transition:all 2s ease-in-out; } .trans_effect:hover { transform:rotate(720deg) scale(2,2); } 2.3 animations @-webkit-keyframes resize { 0% { padding: 0; } 50% { padding: 0 20px; background-color:rgba(190, 206, 235, 0.2); } 100% { padding: 0 100px; background-color:rgba(190, 206, 235, 0.9); } } .anim_box:hover { animation-name: resize; animation-duration: 1.5s; animation-iteration-count: 4; animation-direction: alternate; animation-timing-function: ease-in-out; } Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 15:42:01 "},"gitbook/JavaScript-library/":{"url":"gitbook/JavaScript-library/","title":"JavaScript","keywords":"","body":"CSS Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/JavaScript-library/Object/":{"url":"gitbook/JavaScript-library/Object/","title":"对象","keywords":"","body":"Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 14:35:47 "},"gitbook/JavaScript-library/Object/Create.html":{"url":"gitbook/JavaScript-library/Object/Create.html","title":"创建","keywords":"","body":"JavaScript 创建对象的6种方式 一、工厂模式 function createPerson(name, job) { var o = new Object() o.name = name o.job = job o.sayName = function() { console.log(this.name) } return o } var person1 = createPerson('Jiang', 'student') var person2 = createPerson('X', 'Doctor') 可以无数次调用这个工厂函数，每次都会返回一个包含两个属性和一个方法的对象 工厂模式虽然解决了创建多个相似对象的问题，但是没有解决对象识别问题，即不能知道一个对象的类型 二、构造函数模式 function Person(name, job) { this.name = name this.job = job this.sayName = function() { console.log(this.name) } } var person1 = new Person('Jiang', 'student') var person2 = new Person('X', 'Doctor') 没有显示的创建对象，使用new来调用这个构造函数，使用new后会自动执行如下操作 创建一个新对象 这个新对象会被执行[[prototype]]链接 这个新对象会绑定到函数调用的this 返回这个对象 使用这个方式创建对象可以检测对象类型 person1 instanceof Object // true person1 instanceof Person //true 但是使用构造函数创建对象，每个方法都要在每个实例上重新创建一次 三、原型模式 function Person() { } Person.prototype.name = 'Jiang' Person.prototype.job = 'student' Person.prototype.sayName = function() { console.log(this.name) } var person1 = new Person() 将信息直接添加到原型对象上。使用原型的好处是可以让所有的实例对象共享它所包含的属性和方法，不必在构造函数中定义对象实例信息。 更简单的写法 function Person() { } Person.prototype = { name: 'jiang', job: 'student', sayName: function() { console.log(this.name) } } var person1 = new Person() 将Person.prototype设置为等于一个以对象字面量形式创建的对象，但是会导致.constructor不在指向Person了。 使用这种方式，完全重写了默认的Person.prototype对象，因此 .constructor也不会存在这里 Person.prototype.constructor === Person // false 如果需要这个属性的话，可以手动添加 function Person() { } Person.prototype = { constructor：Person name: 'jiang', job: 'student', sayName: function() { console.log(this.name) } } 不过这种方式还是不够好，应为constructor属性默认是不可枚举的，这样直接设置，它将是可枚举的。所以可以时候，Object.defineProperty方法 Object.defineProperty(Person.prototype, 'constructor', { enumerable: false, value: Person }) 缺点 使用原型，所有的属性都将被共享，这是个很大的优点，同样会带来一些缺点 原型中所有属性实例是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性也勉强可以，毕竟实例属性可以屏蔽原型属性。但是引用类型值，就会出现问题了 function Person() { } Person.prototype = { name: 'jiang', friends: ['Shelby', 'Court'] } var person1 = new Person() var person2 = new Person() person1.friends.push('Van') console.log(person1.friends) //[\"Shelby\", \"Court\", \"Van\"] console.log(person2.friends) //[\"Shelby\", \"Court\", \"Van\"] console.log(person1.friends === person2.friends) // true friends存在与原型中，实例person1和person2指向同一个原型，person1修改了引用的数组，也会反应到实例person2中 四、组合使用构造函数模式和原型模式 这是使用最为广泛、认同度最高的一种创建自定义类型的方法。它可以解决上面那些模式的缺点 使用此模式可以让每个实例都会有自己的一份实例属性副本，但同时又共享着对方法的引用 这样的话，即使实例属性修改引用类型的值，也不会影响其他实例的属性值了 function Person(name) { this.name = name this.friends = ['Shelby', 'Court'] } Person.prototype.sayName = function() { console.log(this.name) } var person1 = new Person() var person2 = new Person() person1.friends.push('Van') console.log(person1.friends) //[\"Shelby\", \"Court\", \"Van\"] console.log(person2.friends) // [\"Shelby\", \"Court\"] console.log(person1.friends === person2.friends) //false 五、动态原型模式 动态原型模式将所有信息都封装在了构造函数中，初始化的时候，通过检测某个应该存在的方法时候有效，来决定是否需要初始化原型 function Person(name, job) { // 属性 this.name = name this.job = job // 方法 if(typeof this.sayName !== 'function') { Person.prototype.sayName = function() { console.log(this.name) } } } var person1 = new Person('Jiang', 'Student') person1.sayName() 只有在sayName方法不存在的时候，才会将它添加到原型中。这段代码只会初次调用构造函数的时候才会执行。 此后原型已经完成初始化，不需要在做什么修改了 这里对原型所做的修改，能够立即在所有实例中得到反映 其次，if语句检查的可以是初始化之后应该存在的任何属性或方法，所以不必用一大堆的if语句检查每一个属性和方法，只要检查一个就行 六、寄生构造函数模式 这种模式的基本思想就是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新建的对象 function Person(name, job) { var o = new Object() o.name = name o.job = job o.sayName = function() { console.log(this.name) } return o } var person1 = new Person('Jiang', 'student') person1.sayName() 这个模式，除了使用new操作符并把使用的包装函数叫做构造函数之外，和工厂模式几乎一样 构造函数如果不返回对象，默认也会返回一个新的对象，通过在构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 15:15:22 "},"gitbook/JavaScript-library/Object/Inherit.html":{"url":"gitbook/JavaScript-library/Object/Inherit.html","title":"继承","keywords":"","body":"js的继承 一、比较 面向对象的继承方式有很多种，原型链继承、借用构造函数继承、组合继承、原型式继承、寄生式继承、寄生式组合继承、深拷贝继承等等。 二、方法 2.1 原型式继承 function createObjWithObj(obj){ // * 传入一个原型对象 function Temp(){} Temp.prototype = obj let o = new Temp() return o } // * 把Person的原型对象当做temp的原型对象 let temp = createObjWithObj(Person.prototype) // * 也可以使用Object.create实现 // * 把Person的原型对象当做temp2的原型对象 let temp2 = Object.create(Person.prototype) 本质上createObjWithObj() 对传入其中的对象执行了一次浅复制，将构造函数 F 的原型直接指向传入的对象。 缺点 原型中引用类型值会被修改 无法传递参数 2.2 寄生式继承 // 寄生式继承 // 我们在原型式的基础上，希望给这个对象新增一些属性方法 // 那么我们在原型式的基础上扩展 function createNewObjWithObj(obj) { let o = createObjWithObj(obj) o.name = \"邵威儒\" o.age = 28 return o } 函数的主要作用是为构造函数新增属性和方法，以增强函数。 缺点（同原型式继承）： 原型中引用类型值会被修改 无法传递参数 3.3 借助构造函数继承 通过这样的方式，会有一个问题，原型对象类似一个共享库，所有实例共享原型对象同一个属性方法，如果原型对象上有引用类型，那么会被所有实例共享，也就是某个实例更改了，则会影响其他实例，我们可以看一下 function Person(name,pets){ // * 父构造函数接收name，pets参数 this.name = name // * 赋值到this上 this.pets = pets // * 赋值到this上 } Person.prototype.eat = function(){ console.log('吃饭') } function Student(num,name,pets){ // * 在子构造函数中也接收参数 Person.call(this,name,pets) // * 在这里把name和pets传参数 this.num = num // * 赋值到this上 } let student = new Student(\"030578000\",\"邵威儒\",[\"旺财\",\"小黄\"]) 2.4 原型链继承 利用原型链的特性，当在自身找不到时，会沿着原型链往上找。 function Person(){ this.name = '邵威儒' this.pets = ['旺财','小黄'] } Person.prototype.eat = function(){ console.log('吃饭') } function Student(){ this.num = \"030578000\" } // * new一个Person的实例，同时拥有其实例属性方法和原型属性方法 let p = new Person() // * 把Student的原型对象指向实例p Student.prototype = p // * 把Student的原型对象的constructor指向Student，解决类型判断问题 Student.prototype.constructor = Student let student = new Student() console.log(student.num) // '030578000' console.log(student.name) // * '邵威儒' console.log(student.pets) // * '[ '旺财', '小黄' ]' student.eat() // '吃饭' 此时关系图为 2.5 组合继承 利用构造继承和原型链组合 function Person(name,pets){ // * 父构造函数接收name，pets参数 this.name = name // * 赋值到this上 this.pets = pets // * 赋值到this上 } Person.prototype.eat = function(){ console.log('吃饭') } function Student(num,name,pets){ // * 在子构造函数中也接收参数 Person.call(this,name,pets) // * 在这里把name和pets传参数 this.num = num // * 赋值到this上 } let p = new Person() Student.prototype = p Student.prototype.constructor = Student let student = new Student(\"030578000\",\"邵威儒\",[\"旺财\",\"小黄\"]) let student2 = new Student(\"030578001\",\"iamswr\",[\"小红\"]) console.log(student.num) // '030578000' console.log(student.name) // '邵威儒' console.log(student.pets) // '[ '旺财', '小黄' ]' student.eat() // '吃饭' student.pets.push('小红') console.log(student.pets) // * [ '旺财', '小黄', '小红' ] console.log(student2.pets) // * [ '小红' ] 这样我们就可以在子构造函数中给父构造函数传参了，而且我们也发现上图中，2个红圈的地方，代码是重复了，那么接下来我们怎么解决呢？ 能否在子构造函数设置原型对象的时候，只要父构造函数的原型对象属性方法呢？ 当然是可以的，接下来我们讲寄生式组合继承，也是目前程序猿认为解决继承问题最好的方案 2.6 寄生式组合继承 function Person(name,pets){ this.name = name this.pets = pets } Person.prototype.eat = function(){ console.log('吃饭') } function Student(num,name,pets){ Person.call(this,name,pets) this.num = num } // * 寄生式继承 function Temp(){} // * 声明一个空的构造函数，用于桥梁作用 Temp.prototype = Person.prototype // * 把Temp构造函数的原型对象指向Person的原型对象 let temp = new Temp() // * 用构造函数Temp实例化一个实例temp Student.prototype = temp // * 把子构造函数的原型对象指向temp temp.constructor = Student // * 把temp的constructor指向Student或者改成Student.prototype.constructor =Student let student1 = new Student('030578001','邵威儒',['旺财','小黄']) console.log(student1) // Student { name: '邵威儒', pets: [ '旺财', '小黄' ],num: '030578001' } let student2 = new Student('030578002','iamswr',['小红']) console.log(student2) // Student { name: 'iamswr', pets: [ '小红' ],num: '030578002' } 至此为止，我们就完成了寄生式组合继承了，主要逻辑就是用一个空的构造函数，来当做桥梁，并且把其原型对象指向父构造函数的原型对象，并且实例化一个temp，temp会沿着这个原型链，去找到父构造函数的原型对象 2.7 Class继承 Class 可以通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 class staff { constructor(){ this.company = \"ABC\"; this.test = [1,2,3]; } companyName(){ return this.company; } } class employee extends staff { constructor(name,profession){ super(); this.employeeName = name; this.profession = profession; } } // 将父类原型指向子类 let instanceOne = new employee(\"Andy\", \"A\"); let instanceTwo = new employee(\"Rose\", \"B\"); instanceOne.test.push(4); // 测试 console.log(instanceTwo.test); // [1,2,3] console.log(instanceOne.companyName()); // ABC // 通过 Object.getPrototypeOf() 方法可以用来从子类上获取父类 console.log(Object.getPrototypeOf(employee) === staff) // 通过 hasOwnProperty() 方法来确定自身属性与其原型属性 console.log(instanceOne.hasOwnProperty('test')) // true // 通过 isPrototypeOf() 方法来确定原型和实例的关系 console.log(staff.prototype.isPrototypeOf(instanceOne)); // true super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象。 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。 只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有 super 方法才能返回父类实例。 super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即super 内部的 this 指的是 B，因此 super() 在这里相当于 A.prototype.constructor.call(this) ES5 和 ES6 实现继承的区别 ES5 的继承，实质是先创造子类的实例对象 this ，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。 ES6 的继承机制完全不同，实质是先创造父类的实例对象 this （所以必须先调用 super() 方法），然后再用子类的构造函数修改 this。 2.8 深拷贝继承 // 方法一：利用JSON.stringify和JSON.parse // 这种方式进行深拷贝，只针对json数据这样的键值对有效 // 对于函数等等反而无效，不好用，接着继续看方法二、三。 // 方法二： function deepCopy(fromObj,toObj) { // 深拷贝函数 // 容错 if(fromObj === null) return null // 当fromObj为null if(fromObj instanceof RegExp) return new RegExp(fromObj) // 当fromObj为正则 if(fromObj instanceof Date) return new Date(fromObj) // 当fromObj为Date toObj = toObj || {} for(let key in fromObj){ // 遍历 if(typeof fromObj[key] !== 'object'){ // 是否为对象 toObj[key] = fromObj[key] // 如果为原始数据类型，则直接赋值 }else{ toObj[key] = new fromObj[key].constructor // 如果为object，则new这个object指向的构造函数 deepCopy(fromObj[key],toObj[key]) // 递归 } } return toObj } let dog = { name:\"小白\", sex:\"公\", firends:[ { name:\"小黄\", sex:\"母\" } ] } let dogcopy = deepCopy(dog) // 此时我们把dog的属性进行修改 dog.firends[0].sex = '公' console.log(dog) // { name: '小白', sex: '公', firends: [ { name: '小黄', sex: '公' }] } // 当我们打印dogcopy，会发现dogcopy不会受dog的影响 console.log(dogcopy) // { name: '小白',sex: '公',firends: [ { name: '小黄', sex: '母' } ] } Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 16:00:51 "},"gitbook/JavaScript-library/Object/Instance.html":{"url":"gitbook/JavaScript-library/Object/Instance.html","title":"构造函数、原型对象实例","keywords":"","body":"构造函数、原型对象实例 一、原型对象实例 每一个函数，都有一个 prototype 属性 所有的引用类型默认都是继承 Object 。 Object.prototype.__proto__ === null; Object.prototype===Object.__proto__.__proto__; Function.prototype===Function.__proto__===Object.__proto__ ; Function.prototype.__proto__ === Object.prototype; p代表__proto__ ， No.2=ƒ () { [native code] } , No.1=[constructor: ƒ, concat: ƒ, find: ƒ, findIndex: ƒ, pop: ƒ, …] 二、构造函数、原型对象、实例之间的关系 三、new 的过程 新生成了一个对象 链接到原型 绑定 this 返回新对象 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 14:58:59 "},"gitbook/JavaScript-library/ThisDirection.html":{"url":"gitbook/JavaScript-library/ThisDirection.html","title":"this指向","keywords":"","body":"this 指向问题 JS中 this 的指向不同于其他语言，JS中的 this 不是指向定义他的位置，而是在哪调用它它就指向哪里。 JS中，普通的函数调用方式有三种：直接调用、方法调用和 new 调用。除此之外，还有一些特殊的调用方式，比如通过 bind() 将函数绑定到对象之后再进行调用、通过 call()、apply()进行调用等。而 es6 引入了箭头函数之后，箭头函数调用时，其 this 指向又有所不同。下面就来分析这些情况下的 this 指向。 一、 直接调用 首先来看直接调用，就是通过 函数名(...) 这种方式调用。这时候，函数内部的 this 指向全局对象，在浏览器中全局对象是 window，在 NodeJs 中全局对象是 global。 // 简单兼容浏览器和 NodeJs 的全局对象 const _global = typeof window === \"undefined\" ? global : window; function test() { console.log(this === _global); // true } test(); // 直接调用 注意！！！直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过 函数名(...) 来对函数进行调用的方式，都称为直接调用 1.1 bind() 对直接调用的影响 这种情况在 react 和 ES6 中经常会遇到，绑定事件其实类似于之前的 var that = this; Function.prototype.bind() 的作用是将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，其 this 始终指向绑定的对象 const obj = {}; function test() { console.log(this === obj); } const testObj = test.bind(obj); test(); // false testObj(); // true 那么 可能有人会问 bind 做了什么，别着急 往下看 const obj = {}; function test() { console.log(this === obj); } // 自定义的函数，模拟 bind() 对 this 的影响 function myBind(func, target) { return function () { return func.apply(target, arguments); }; } const testObj = myBind(test, obj); test(); // false testObj(); // true 从上面的示例可以看到，首先，通过闭包，保持了 target ，即绑定的对象；然后在调用函数的时候，对原函数使用了 apply 方法来指定函数的 this 。当然原生的bind() 实现可能会不同，而且更高效。但这个示例说明了 bind() 的可行性。 1.2 call 和 apply 对 this 的影响 上面用到了 Function.prototype.apply()，与之类似的还有 Function.prototype.call()。它们的第一个参数都是指定函数运行时其中的 this 指向。 不过使用 apply 和 call 的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那 apply 和 call 不会像预期那样执行，比如 const obj = {}; function test() { console.log(this === obj); } // 绑定到一个新对象，而不是 obj const testObj = test.bind({}); test.apply(obj); // true // 期望 this 是 obj，即输出 true // 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false testObj.apply(obj); // false 二、方法调用 方法调用是指通过对象来调用其方法函数，它是对象方法、函数(...) 这样的调用形式。这种情况下，函数中的 this 指向调用该方法的对象。但是，同样需要注意 bind() 的影响。 // 第一种方式，定义对象的时候定义其方法 const obj = { test() { console.log(this === obj); } }; // 第二种方式，对象定义好之后为其附加一个方法(函数表达式) obj.test2 = function() { console.log(this === obj); }; // 第三种方式和第二种方式原理相同 // 是对象定义好之后为其附加一个方法(函数定义) function t() { console.log(this === obj); } obj.test3 = t; // 这也是为对象附加一个方法函数 // 但是这个函数绑定了一个不是 obj 的其它对象 obj.test4 = (function() { console.log(this === obj); }).bind({}); obj.test(); // true obj.test2(); // true obj.test3(); // true // 受 bind() 影响，test4 中的 this 指向不是 obj obj.test4(); // false 这里需要注意的是，后三种方式都是预定定义函数，再将其附加给 obj 对象作为其方法。再次强调，函数内部的 this 指向与定义无关，受调用方式的影响。 2.1 方法中 this 指向全局对象的情况 注意这里说的是方法中而不是方法调用中。方法中的 this 指向全局对象，如果不是因为 bind()，那就一定是因为不是用的方法调用方式，比如 const obj = { test() { console.log(this === obj); } }; const t = obj.test; t(); // false t 就是 obj 的 test 方法，但是 t() 调用时，其中的 this 指向了全局。 之所以要特别提出这种情况，主要是因为常常将一个对象方法作为回调传递给某个函数之后，却发现运行结果与预期不符——因为忽略了调用方式对 this 的影响。 三、new 调用 在 es6 之前，每一个函数都可以当作是构造函数，通过 new 调用来产生新的对象(函数内无特定返回值的情况下)。而 es6 改变了这种状态，虽然 class 定义的类用 typeof 运算符得到的仍然是 \"function\"，但它不能像普通函数一样直接调用；同时，class 中定义的方法函数，也不能当作构造函数用 new 来调用。 而在 es5 中，用 new 调用一个构造函数，会创建一个新对象，而其中的 this 就指向这个新对象。这没有什么悬念，因为 new 本身就是设计来创建新对象的。 var data = \"Hi\"; // 全局变量 function AClass(data) { this.data = data; } var a = new AClass(\"Hello World\"); console.log(a.data); // Hello World console.log(data); // Hi var b = new AClass(\"Hello World\"); console.log(a === b); // false 四、箭头函数中的 this 先来看看 MDN 上对箭头函数的说明 An arrow function expression has a shorter syntax than a function expression and does not bind its own this, arguments,super, or new.target. Arrow functions are always anonymous. These function expressions are best suited for non-method functions, and they cannot be used as constructors. 这里已经清楚了说明了，箭头函数没有自己的 this 绑定。箭头函数中使用的 this，其实是直接包含它的那个函数或函数表达式中的 this。比如 onst obj = { test() { const arrow = () => { // 这里的 this 是 test() 中的 this， // 由 test() 的调用方式决定 console.log(this === obj); }; arrow(); }, getArrow() { return () => { // 这里的 this 是 getArrow() 中的 this， // 由 getArrow() 的调用方式决定 console.log(this === obj); }; } }; obj.test(); // true const arrow = obj.getArrow(); arrow(); // true 示例中的两个 this 都是由箭头函数的直接外层函数(方法)决定的，而方法函数中的 this 是由其调用方式决定的。上例的调用方式都是方法调用，所以 this 都指向方法调用的对象，即 obj。 五、example var x = 20; var b={ x:10, } var a = { x: 15, fn: function () { var x = 30; return function () { return this.x } }, test: function () { setTimeout(function () { console.log(this.x) }, 500); }, test2: function () { setTimeout(() => { console.log(this.x) }, 500); }, } console.log(a.fn()); console.log((a.fn())()); console.log(a.fn()()); console.log(a.fn()() == (a.fn())()); console.log(a.fn().call(this)); console.log(a.test()); console.log(a.test2()); 答案 console.log(a.fn()); 对象调用方法，返回了一个方法。 function() {return this.x} console.log((a.fn())()); a.fn()返回的是一个函数，()()这是自执行表达式。this -> window 20 console.log(a.fn()()); a.fn()相当于在全局定义了一个函数，然后再自己调用执行。this -> window 20 console.log(a.fn()() == (a.fn())()); true console.log(a.fn().call(this)); 这段代码在全局环境中执行，this -> window 20 console.log(a.fn().call(a)); this -> a 15 console.log(a.test()); this -> window 20 console.log(a.test2()); this -> a 15 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-12 13:57:29 "},"gitbook/JavaScript-library/ToString.html":{"url":"gitbook/JavaScript-library/ToString.html","title":"toString","keywords":"","body":"toString作用 返回值： toString() 函数的返回值为 Sring 类型,返回当前对象的字符串形式。 JavaScript 的许多内置对象都重新了盖函数，来实现自身的功能需要。 类型 行为描述 Array 将数组的每个元素转化为字符串，并将他们之间用英文逗号连接起来 Boolean 如果布尔值是true，则返回“true”，否则返回“false” Function 当 name 是一个函数的名称，调用toString方法时返回\"function name(){}\" String 返回string的值 Number 返回数组的字符串表示 Object 返回\"[object ObjectName]\" 其中 ObjectName是对象类型的名称， Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 15:49:04 "},"gitbook/JavaScript-library/PointChange.html":{"url":"gitbook/JavaScript-library/PointChange.html","title":"bind,apply,call","keywords":"","body":"一、bind、apply与call三者区别 在JS中，这三者都是用来改变函数的this对象的指向的，他们有什么样的区别呢。 在说区别之前还是先总结一下三者的相似之处： 都是用来改变函数的this对象的指向的。 第一个参数都是this要指向的对象。 都可以利用后续参数传参。 那么他们的区别在哪里的，先看一个例子。 var xw = { name: \"小王\", gender: \"男\", age: 24, say: function () { alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age); } } var xh = { name: \"小红\", gender: \"女\", age: 18 } xw.say(); 那么如何用xw的 say 方法来显示xh的数据呢。 对于call可以这样： xw.say.call(xh); 对于apply可以这样： xw.say.apply(xh); 而对于bind来说需要这样： xw.say.bind(xh)(); 总之：bind 与 apply 、 call 最大的区别就是： bind 不会立即调用，其他两个会立即调用， apply 与 call 的区别是 apply 第二个是参数组，但是在确定的参数下，还是最好用 call ， call 的效果会更高，但是在函数的延展性上使用 apply 更好 二、手写方法 2.1 手写一个call方法 考虑两点 第一个参数为undefined或null的时候，那么会转变为window 改变了this执行，让新的对象可以执行该函数。 Function.prototype.myCall = function (context) { // 判断是否是undefined和null if (typeof context === 'undefined' || context === null) { context = window } context.fn = this let args = [...arguments].slice(1) let result = context.fn(...args) delete context.fn return result } 2.2 apply Function.prototype.myApply = function (context) { if (typeof context === 'undefined' || context === null) { context = window } context.fn = this let args = arguments[1] let result if (args) { result = context.fn(...args) } else { result = context.fn() } delete context.fn return result } 2.3 bind实现 这里需要注意下，因为 bind 转换后的函数可以作为构造函数使用，此时 this 应该指向构造出的实例，而 bind 函数绑定的第一个参数。 Function.prototype.myBind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } let _this = this let args = [...arguments].slice(1) return function F() { // 判断是否被当做构造函数使用 if (this instanceof F) { return _this.apply(this, args.concat([...arguments])) } return _this.apply(context, args.concat([...arguments])) } } Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 15:48:57 "},"gitbook/JavaScript-library/CrossDomain.html":{"url":"gitbook/JavaScript-library/CrossDomain.html","title":"跨域","keywords":"","body":"跨域 一、介绍 什么是跨域？ 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源 什么是同源策略？ 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 url 哪些地方不同算作跨域？协议、域名、端口，三个有两个不同就是不同的源，就是跨域 二、 限制 同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js对象无法获得 AJAX 请求不能发送 三、解决办法 跨域解决方案 通过jsonp跨域 iframe跨域 跨域资源共享（CORS） nginx代理跨域 nodejs中间件代理跨域 3.1 通过jsonp跨域 通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.domain2.com:8080/login?user=admin&callback=onBack'; document.head.appendChild(script); // 回调执行函数 function onBack(res) { alert(JSON.stringify(res)); } 3.2 跨域资源共享（CORS） 普通跨域请求： 只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。 需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：三、nginx反向代理中设置proxy_cookie_domain 和 四、NodeJs中间件代理中cookieDomainRewrite参数的设置。 目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 jQuery ajax $.ajax({ xhrFields: { withCredentials: true,// 前端设置是否带cookie }, crossDomain: true,// 会让请求头中包含跨域的额外信息，但不会含cookie... }); 3.3 nginx代理跨域 nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 location/{add_header Access-Control-Allow-Origin*;} nginx反向代理接口跨域 跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 nginx具体配置： server { listen 81; server_name www.domain1.com; location / { proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; } } 3.4 Nodejs中间件代理跨域 node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。 非vue框架的跨域（2次跨域） 利用node + express + http-proxy-middleware搭建一个proxy服务器。 //前端代码示例： var xhr = new XMLHttpRequest(); // 前端开关：浏览器是否读写cookie xhr.withCredentials = true; // 访问http-proxy-middleware代理服务器 xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true); xhr.send(); // 中间件服务器： var express = require('express'); var proxy = require('http-proxy-middleware'); var app = express(); app.use('/', proxy({ // 代理跨域目标接口 target: 'http://www.domain2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) { res.header('Access-Control-Allow-Origin', 'http://www.domain1.com'); res.header('Access-Control-Allow-Credentials', 'true'); }, // 修改响应信息中的cookie域名 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 })); app.listen(3000); console.log('Proxy server is listen at port 3000...'); Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 13:32:31 "},"gitbook/JavaScript-library/Traversing.html":{"url":"gitbook/JavaScript-library/Traversing.html","title":"二叉树遍历","keywords":"","body":"二叉树遍历 一、 介绍： 所谓二叉树的遍历，是指按照一定的顺序对二叉树的每一个节点均访问一次，且只访问一次。 二、方式 按照访问根节点的访问位置不同通常把二叉树的遍历分为三种方式： 前序遍历、中序遍历、后序遍历 2.1 前序遍历 首先访问根节点，然后访问根节点的左子树，在访问根节点的右子树。 遍历结果：abdefgc function DLR(tree){ console.log(tree.value); if(tree.left){ DLR(tree.left); } if(tree.right){ DLR(tree.right); } } 2.2 中序遍历 首先访问根节点的左子树，然后访问根节点，再访问根节点右子树 遍历结果: debgfac function LDR(tree){ if(tree.left){ LDR(tree.left); } console.log(tree.value); if(tree.right){ LDR(tree.right); } } 2.3 后序遍历 首先访问根节点的左子树，然后访问根节点的右子树，最后访问根节点 遍历结果：edgfbca function LRD(tree){ if(tree.left){ LRD(tree.left); } if(tree.right){ LRD(tree.right); } console.log(tree.value); } Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 11:56:06 "},"gitbook/JavaScript-library/EventLoop.html":{"url":"gitbook/JavaScript-library/EventLoop.html","title":"Event Loop","keywords":"","body":"Event Loop 一、前言 Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。 为啥要弄懂Event Loop? 了解JavaScript的运行机制。 现在在前端领域各种技术层出不穷，掌握底层原理，可以让自己以不变，应万变 二、栈、队列 2.1 栈（Stack） 栈在计算机科学中是限定仅在表尾进行插入或删除操作的线性表。 栈是一种数据结构，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。 栈是只能在某一端插入和删除的特殊线性表。 2.2 队列（Queue） 在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out） 三、分类 在JavaScript中，任务被分为两种，一种宏任务（MacroTask）也叫Task，一种叫微任务（MicroTask）。 3.1 MacroTask（宏任务） script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。 3.2 MicroTask（微任务） Process.nextTick（Node独有）、Promise、Object.observe(废弃) 三、浏览器中Event Loop Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。 3.1 JS调用栈 JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。 3.2 同步任务和异步任务 Javascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。 事件循环的进程模型 选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务（MicroTask）的执行步骤。 将事件循环中的任务设置为已选择任务。 执行任务。 将事件循环中当前运行任务设置为null。 将已经运行完成的任务从任务队列中删除。 microtasks步骤：进入microtask检查点。 更新界面渲染。 返回第一步。 执行进入microtask检查点时，用户代理会执行以下步骤： 设置microtask检查点标志为true。 当事件循环microtask执行不为空时：选择一个最先进入的microtask队列的microtask，将事件循环的microtask设置为已选择的microtask，运行microtask，将已经执行完成的microtask为null，移出microtask中的microtask。 设置进入microtask检查点的标志为false。 执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去检查微任务(microTask)队列是否为空，如果为空的话，就执行Task（宏任务），否则就一次性执行完所有微任务。 每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。 四、example console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); Promise.resolve().then(function() { console.log('promise1'); }).then(function() { console.log('promise2'); }); console.log('script end'); 4.1 第一次执行： Tasks：run script、 setTimeout callback Microtasks：Promise then JS stack: script Log: script start、script end。 执行同步代码，将宏任务（Tasks）和微任务(Microtasks)划分到各自队列中。 4.2 第二次执行： Tasks：run script、 setTimeout callback Microtasks：Promise2 then JS stack: Promise2 callback Log: script start、script end、promise1、promise2 执行宏任务后，检测到微任务(Microtasks)队列中不为空，执行Promise1，执行完成Promise1后，调用Promise2.then，放入微任务(Microtasks)队列中，再执行Promise2.then。 4.3 第三次执行： Tasks：setTimeout callback Microtasks： JS stack: setTimeout callback Log: script start、script end、promise1、promise2、setTimeout 当微任务(Microtasks)队列中为空时，执行宏任务（Tasks），执行setTimeout callback，打印日志。 4.4 第四次执行： Tasks：setTimeout callback Microtasks： JS stack: Log: script start、script end、promise1、promise2、setTimeout 清空Tasks队列和JS stack。 以上执行帧动画可以查看Tasks, microtasks, queues and schedules 五、example2 console.log('script start') async function async1() { await async2() console.log('async1 end') } async function async2() { console.log('async2 end') } async1() setTimeout(function() { console.log('setTimeout') }, 0) new Promise(resolve => { console.log('Promise') resolve() }) .then(function() { console.log('promise1') }) .then(function() { console.log('promise2') }) console.log('script end') 这里需要先理解async/await。 async/await 在底层转换成了 promise 和 then 回调函数。 也就是说，这是 promise 的语法糖。 每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。 async/await 的实现，离不开 Promise。从字面意思来理解，async 是“异步”的简写，而 await 是 async wait 的简写可以认为是等待异步方法执行完成。 关于73以下版本和73版本的区别 在老版本版本以下，先执行promise1和promise2，再执行async1。 在73版本，先执行async1再执行promise1和promise2。 73版本 首先，打印script start，调用async1()时，返回一个Promise，所以打印出来async2 end。 每个 await，会新产生一个promise,但这个过程本身是异步的，所以该await后面不会立即调用。 继续执行同步代码，打印Promise和script end，将then函数放入微任务队列中等待执行。 同步执行完成之后，检查微任务队列是否为null，然后按照先入先出规则，依次执行。 再回到await的位置执行返回的 Promise 的 resolve 函数，这又会把 resolve 丢到微任务队列中，打印async1 end 然后先执行打印promise1,此时then的回调函数返回undefinde，此时又有then的链式调用，又放入微任务队列中，再次打印promise2。 当微任务队列为空时，执行宏任务,打印setTimeout。 复制文件 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 14:26:40 "},"gitbook/JavaScript-library/Currying.html":{"url":"gitbook/JavaScript-library/Currying.html","title":"柯里化","keywords":"","body":"一、通用版 function curry(fn) { var args = Array.prototype.slice.call(arguments, 1); return function () { var newArgs = args.concat(Array.prototype.slice.call(arguments)); return fn.apply(this, newArgs); } } 执行： function multiFn(a, b, c) { return a * b * c; } var multi = curry(multiFn); multi(2, 3, 4); 二、改进版 就题目而言，是需要执行三次函数调用，那么针对柯里化后的函数，如果传入的参数没有 3 个的话，就继续执行 curry 函数接收参数，如果参数达到 3 个，就执行柯里化了的函数。 function curry(fn, args) { var length = fn.length; var args = args || []; return function () { newArgs = args.concat(Array.prototype.slice.call(arguments)); if (newArgs.length 三、优化版 function multi() { var args = Array.prototype.slice.call(arguments); var fn = function () { var newArgs = args.concat(Array.prototype.slice.call(arguments)); return multi.apply(this, newArgs); } fn.toString = function () { return args.reduce(function (a, b) { return a * b; }) } return fn; } 最后这个其实是利用了toString()函数的返回值为String类型。返回当前对象的字符串形式。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-09 17:38:01 "},"gitbook/HTTP-library/":{"url":"gitbook/HTTP-library/","title":"HTTP","keywords":"","body":"Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-09 19:50:35 "},"gitbook/HTTP-library/Code.html":{"url":"gitbook/HTTP-library/Code.html","title":"状态码","keywords":"","body":"HTTP常见状态码 2XX 成功 200 OK，表示从客户端发来的请求在服务器端被正确处理 204 No content，表示请求成功，但响应报文不含实体的主体部分 206 Partial Content，进行范围请求 3XX 重定向 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL 302 found，临时性重定向，表示资源临时被分配了新的 URL 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况 307 temporary redirect，临时重定向，和302含义相同 4XX 客户端错误 400 bad request，请求报文存在语法错误 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 403 forbidden，表示对请求资源的访问被服务器拒绝 404 not found，表示在服务器上没有找到请求的资源 5XX 服务器错误 500 internal sever error，表示服务器端在执行请求时发生了错误 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-09 19:54:48 "},"gitbook/HTTP-library/Cache.html":{"url":"gitbook/HTTP-library/Cache.html","title":"HTTP缓存","keywords":"","body":"HTTP缓存 一、介绍 Http 缓存机制作为 web 性能优化的重要手段，对于从事 Web 开发的同学们来说，应该是知识体系库中的一个基础环节，同时对于有志成为前端架构师的同学来说是必备的知识技能。 在介绍 HTTP 缓存之前，先简单介绍一下HTTP报文 HTTP 报文就是浏览器和服务器间通信时发送及响应的数据块。 浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文。 报文信息主要分为两部分 包含属性的首部(header)--------------------------附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中 包含数据的主体部分(body)-----------------------HTTP请求真正想要传输的部分 二、 缓存分类 HTTP 缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存）两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。 2.1 强制缓存 强制缓存（状态码还是200）命中强缓存时，浏览器并不会将请求发送给服务器。在 Chrome 的开发者工具中看到 http 的返回码是200，但是在 Size 列会显示为(from cache)。 对于强制缓存来说，响应 header 中会有两个字段来标明失效规则（Expires/Cache-Control） 使用 chrome 的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况 Expires Expires 的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。 不过 Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用 HTTP 1.1，所以它的作用基本忽略。 另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。 所以HTTP 1.1 的版本，使用 Cache-Control 替代。 Cache-Control Cache-Control 是最重要的规则。常见的取值有 private 、public 、no-cache 、max-age ，no-store，默认为 private 。 private: 客户端可以缓存 public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的） max-age=xxx: 缓存的内容将在 xxx 秒后失效 no-cache: 需要使用对比缓存来验证缓存数据（后面介绍） no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so...基本上和它说886） 2.2 对比缓存 对比缓存（状态码还是304）对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。 浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。 再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。 Last-Modified / If-Modified-Since Last-Modified： 浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间 If-Modified-Since： 再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。 服务器收到请求后发现有头 If-Modified-Since 则与被请求资源的最后修改时间进行比对。 若资源的最后修改时间大于 If-Modified-Since ，说明资源又被改动过，则响应整片资源内容，返回状态码200； 若资源的最后修改时间小于或等于 If-Modified-Since ，说明资源无新修改，则响应 HTTP 304，告知浏览器继续使用所保存的cache。 Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since ） ETag(resp)/If-None-Match（req） 与 Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag 可以保证每一个资源是唯一的，资源变化都会导致ETag变化*。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的 If-None-Match 值来判断是否命中缓存。 三、 总结 对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。 对于比较缓存，将缓存信息中的 Etag 和 Last-Modified 通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 15:42:14 "},"gitbook/HTTP-library/InternetProtocol.html":{"url":"gitbook/HTTP-library/InternetProtocol.html","title":"因特网协议","keywords":"","body":"五层因特网协议 因特网协议的缩写是IP，意思是网络之间互连的协议，也就是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。 通俗的讲：IP地址也可以称为互联网地址或Internet地址。是用来唯一标识互联网上计算机的逻辑地址. 因特网协议栈共有五层：应用层、传输层、网络层、链接层和物理层。不同于OSI七层模型这也是实际使用中使用的分层方式。 互联网的每一层，都定义了很多协议。这些协议的总称，就叫做\"互联网协议\"（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。 一、实体层 实体层也叫物理层，它就是把电脑连接起来的物理手段。它主要规定了网络的一些特性，作用是负责传送0和1的电信号。 二、链接层 两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。\"链接层\"的功能:它在\"实体层\"的上方，确定了0和1的分组方式。在两个相邻节点之间传送数据时，数据链路层将网络层接下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等） 2.1 以太网协议 早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做\"以太网\"（Ethernet）的协议，占据了主导地位。 以太网规定，一组电信号构成一个数据包，叫做\"帧\"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data） \"标头\"包含数据包的一些说明项，比如发送者、接受者、数据类型等等；\"数据\"则是数据包的具体内容。如果数据很长，就必须分割成多个帧进行发送。 2.2 MAC地址 以太网数据包的\"标头\"，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？ 以太网规定，连入网络的所有设备，都必须具有\"网卡\"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。有了MAC地址，就可以定位网卡和数据包的路径了。 2.3广播 定义地址只是第一步，后面还有更多的步骤。 首先，一块网卡怎么会知道另一块网卡的MAC地址？ 回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。 其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？ 回答是以太网采用了一种很\"原始\"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。 上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的\"标头\"，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做\"广播\"（broadcasting）。 有了数据包的定义、网卡的MAC地址、广播的发送方式，\"链接层\"就可以在多台计算机之间传送数据了。 三、网络层 网络层作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做\"网络地址\"，简称\"网址\"。 于是，\"网络层\"出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。 网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。 3.1IP协议 规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。 目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。 但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。 那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数\"子网掩码\"（subnet mask）。 所谓\"子网掩码\"，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。 是否子在同一子网 算法只要把ＩＰ和子网掩码的每位数AND就可以了。 　　AND方法：0和1＝0　0和0＝0　1和1＝1 　　如：And　192.168.0.1，255.255.255.0，先转换为二进制，然后AND每一位 　　ＩＰ　　　　　　11000000.10101000.00000000.00000001 　　子网掩码　　　　11111111.11111111.11111111.00000000 　　得出AND结果　　 11000000.10101000.00000000.00000000 　　转换为十进制192.168.0.0，这就是网络标识， 再将子网掩码反取，也就是： 00000000.00000000.00000000.11111111， 　　 与IP　AND　得出结果： 00000000.00000000.00000000.00000001， 　　 转换为10进制，即0.0.0.1， 　 　这0.0.0.1就是主机标识。 3.2 IP数据包 根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。 但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？ 回答是不需要，我们可以把IP数据包直接放进以太网数据包的\"数据\"部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。 具体来说，IP数据包也分为\"标头\"和\"数据\"两个部分。 \"标头\"部分主要包括版本、长度、IP地址等信息，\"数据\"部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样 3.3 ARP协议 因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。 所以，我们需要一种机制，能够从IP地址得到MAC地址。 这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的\"网关\"（gateway），让网关去处理。 第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个\"广播\"地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。 总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。 四、传输层 有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。 接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？ 也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做\"端口\"（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。 \"端口\"是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。 \"传输层\"的功能，就是建立\"端口到端口\"的通信。相比之下，\"网络层\"的功能是建立\"主机到主机\"的通信。只要确定主机和端口，我们就能实现程序之间的交流。 4.1 UDP协议 现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。 UDP数据包，也是由\"标头\"和\"数据\"两部分组成。 \"标头\"部分主要定义了发出端口和接收端口，\"数据\"部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的\"数据\"部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样： 4.2 TCP协议 UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。 为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。 因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。 TCP数据包和UDP数据包一样，都是内嵌在IP数据包的\"数据\"部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 五、应用层 应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。 这是最高的一层，直接面对用户。它的数据就放在TCP数据包的\"数据\"部分。因此，现在的以太网的数据包就变成下面这样。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 16:23:57 "},"gitbook/HTTP-library/Tcp.html":{"url":"gitbook/HTTP-library/Tcp.html","title":"TCP通信","keywords":"","body":"TCP 通信 一、 OSI 七层协议模型、TCP/IP 四层模型各层对应 二、HTTP 与 HTTPS 的区别 三 、TCP/IP 通信传输流 发送端在层与层之间传输数据时，每经过一层必定会加上一个该层的首部信息。反之，接收端在层与层之间传输数据时，每经过一层会把相关的首部信息去掉。 四、TCP 三次握手和四次挥手 TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 三次握手 第一次握手： 建立连接时，向服务器发出连接请求报文，客户端进程进入已发送状态状态,等待服务器确认； 第二次握手： 服务器收到请求后，如果同意连接，则发出确认报文，此时服务器进程进入了 同步收到状态； 第三次握手： 客户端收到服务器的确认报文后，要向服务器给出确认，此时，TCP 连接建立，客户端进入已建立连接状态。 完成三次握手，客户端与服务器开始传送数据。 建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由 TCP 的半关闭（half-close）造成的。 四次挥手 第一次挥手： 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部 FIN=1，其序列号为 seq = u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入 FIN-WAIT-1（终止等待1）状态。 第二次挥手： 服务器收到连接释放报文，发出确认报文，ACK = 1，ack = u + 1，并且带上自己的序列号 seq = v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。 TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 第三次挥手： 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN = 1，ack = u + 1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq = w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。 第四次挥手： 客户端收到服务器的连接释放报文后，必须发出确认，ACK = 1，ack = w + 1，而自己的序列号是 seq = u + 1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。 注意此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。 服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。 可以看到，服务器结束 TCP 连接的时间要比客户端早一些。 四次的原因 这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。 但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你未必会马上会关闭 SOCKET ,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的. 由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 五、DNS 域名解析 当你在浏览器的地址栏输入 https://jianshu.com 后会发生什么，大家在心中肯定是有一个大概的，这里我将 DNS 域名解析 这个步骤详细的讲一遍。在讲概念之前我先放上一张经典的图文供大家思考一分钟。 六、查找域名对应的 IP 地址的具体过程 浏览器搜索自己的 DNS 缓存（浏览器维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步； 搜索操作系统中的 DNS 缓存；如果没有命中，进入下一步； 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步； 操作系统将域名发送至 LDNS （本地区域名服务器），LDNS 查询自己的 DNS 缓存（一般命中率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求： LDNS向 Root Name Server（根域名服务器，如com、net、im 等的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 im 域的顶级域名服务器的地址； LDNS 向 im 域的顶级域名服务器发起请求，返回jianshu.com 域名服务器地址； LDNS 向 jianshu.com 域名服务器发起请求，得到jianshu.com 的 IP 地址； LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来。 七、DNS Prefetch 即 DNS 预获取，是前端优化的一部分。一般来说，在前端优化中与 DNS 有关的有两点： 减少 DNS 的请求次数 进行 DNS 预获取 典型的一次 DNS 解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能减少用户的等待时间，提升用户体验。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 16:40:17 "},"gitbook/Regular-library/":{"url":"gitbook/Regular-library/","title":"Regular","keywords":"","body":"正则 1. 概念 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 2. 正则目的 给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）； 可以通过正则表达式，从字符串中获取我们想要的特定部分。 3. 正则特点 灵活性、逻辑性和功能性非常的强； 可以迅速地用极简单的方式达到字符串的复杂控制。 对于刚接触的人来说，比较晦涩难懂。 4. 正则的组成 5. 参考资料 了解正则的运行情况可以使用正则工具 地址 正则视频可以查看慕课网 正则初识（一）规则 Linux--shell脚本之正则表达式 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-28 17:39:13 "},"gitbook/Regular-library/composition.html":{"url":"gitbook/Regular-library/composition.html","title":"正则组成","keywords":"","body":"正则的组成 1. 字符类 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，n 匹配字符 n。\\n 匹配一个换行符。序列 \\\\ 匹配 \\ 而 \\( 则匹配 (。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]。 \\W 匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_]。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， [abc] 可以匹配 plain 中的 a。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， [^abc] 可以匹配 \"plain\" 中的p、l、i、n。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，[a-z] 可以匹配 a 到 z 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，'a-z可以匹配任何不在a到z` 范围内的任意字符。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v] 。 \\S 匹配任何非空白字符。等价于 [^\\f\\ [^ \\f\\n\\r\\t\\v]。 2. 量词 量词：在正则中表现出现次数的 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 \"z\" 以及 \"zoo\"。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 、 \"does\" 中的 \"does\" 、 \"doxy\" 中的 \"do\" 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 {n,m} m 和 n 均为非负整数，其中n 3. 位置限定符 字符 描述 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\\n' 或 '\\r' 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\\n' 或 '\\r' 之前的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\\b' 可以匹配\"never\" 中的 'er'，但不能匹配 \"verb\" 中的 'er'。 \\B 匹配非单词边界。'er\\B' 能匹配 \"verb\" 中的 'er'，但不能匹配 \"never\" 中的 'er'。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 5. 正则修饰符 字符 描述 i 忽略大小写 m 表示可以进行多行匹配，一般和$,^配合使用 g 全局查询 s 将字符串视为单行，换行符作为普通字符 ``` // i 使用 var str=\"bAcd\"; console.log(str.match(/a/i)) //如果不适用i不会匹配，使用i，忽略大小写，会匹配上A // g 使用 var str=\"abAcd\"; console.log(str.match(/a/gi)) //如果不适用g只会匹配上{a}，使用g，全局查询会匹配上[a,A] // m 使用 var str=\"bd76dfsdfsdfsdfs\\r\\nb76dsfsdb8fsdf\"; console.log(str.match(/^b./gm)); //如果不适用m只会匹配上{bd}，使用m表明可以进行多行匹配，全局查询会匹配上[bd,b7] // s 使用 var str=\"sbcpr\\nydddpray\"; console.log(str.match(/pr.y/gs)); //如果不适用s只会匹配上{pray}，使用m表明可以进行多行匹配，全局查询会匹配上[pr\\ny,pray] ``` Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-28 17:40:44 "},"gitbook/Regular-library/methods.html":{"url":"gitbook/Regular-library/methods.html","title":"正则方法","keywords":"","body":"方法 正则的方法包括正则的方法、js使用正则的方法 1. 正则的方法 1.1 test方法 该方法用来测试某个字符串是否与正则匹配，匹配就返回true，否则返回false。该方法接受一个字符串作为参数 ``` var reg=/boy(s)?\\s+and\\s+girl(s)?/gi; console.log(reg.test('boy and girl')); ``` 1.2 exec方法 该方法属于一个比较复杂的方法，它接受一个字符串，返回的是一个数组，数组中第0个元素是匹配的子字符串，第二个元素是正则中的第一个子分组匹配的结果（如果有子分组，即正则中存在用圆括号括起来的分组），第三个是正则中第二个子分组匹配的结果（如果有第二个子分组）...以此类推，如果没有正则子分组，那么该数组长度仅仅为1，就是匹配到的那个子字符串。同时，返回的这个数组同时还是一个对象，它拥有两个属性，分别为index表示当前匹配到的子字符串所处的位置，input属性表示被匹配的原始字符串。最后，该方法中的正则对象如果不是全局匹配，即没有g修饰符，则每次调用只会从字符串开头处匹配第一个结果，且每次调用结果都是一样的。只有指定为全局匹配，才能够按照从左往右依次去匹配，每次调用匹配一个结果，正则对象的lastIndex属性前进到本次匹配的末尾位置，下回再调用的时候，会从lastIndex处开始匹配而不是从头匹配。 ``` var reg=/(\\w)l(\\w)/g; var str=\"hello world hello 123 hello programmer hello test\"; var arr=reg.exec(str); while(arr){ console.dir(arr); console.log(\"lastIndex:\"+reg.lastIndex); arr=reg.exec(str); } ``` 2. js使用正则的方法 2.1 search方法 该方法是string对象的一个方法，用来查找第一次匹配的子字符串的位置，如果找到就返回一个number类型的index值，否则返回-1,它返回的只是第一次匹配的位置。 ``` var str=\"hello world\"; console.log(str.search(/o/g)); ``` 2.2 replace方法 该方法用来将字符串中的某些子串替换为需要的内容，接受两个参数，第一个参数可以为正则或者子字符串，表示匹配需要被替换的内容，第二个参数为被替换的新的子字符串。如果声明为全局匹配则会替换所有结果，否则只替换第一个匹配到的结果。 ``` var str=\"hello world,hello test\"; console.log(str.replace(/hello/g,'hi')); ``` 7.3 split方法 该方法主要用来将一个字符串拆分成一个数组，它接受一个正则或者子字符（串）作为参数，返回一个数组，简单情况下，我们不需要使用正则，只有在字符串拆分规则不统一的情况下才需要使用正则，如下： ``` var str=\"how|old*are you\"; var arr=str.split(/\\||\\*|\\s+/); console.log(arr); ``` 7.4. match方法 该方法接受一个正则作为参数，用来匹配一个字符串，它的输出结果在不是全局匹配的情况下和exec方法的结果一致即一个数组并带有额外的属性，如果采用全局匹配，则不返回任何和其被匹配字符串相关的信息，只返回匹配的结果。 ``` var reg3=/(\\w)s(\\w)/g; var str4=\"ws1estqsa\"; console.dir(str4.match(reg3)); ``` Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-27 16:16:03 "},"gitbook/Regular-library/used.html":{"url":"gitbook/Regular-library/used.html","title":"常用正则","keywords":"","body":"常用正则： 查看正则运行情况 2 到 9 位中文昵称：^[\\u4e00-\\u9fa5]{2,9}$ 只能是字母、数字和下划线，长度不限制一到多：^\\w+$ 允许 小写字母 a-z、大写字母 A-Z、数字 0-9、下划线 、 连接符 -，且长度在 6-18 位数：`/^[a-zA-Z0-9-]{6,18}$/` 必须包含数字+小写字母+大写字母的密码，且长度在8-10位之间：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 验证 Email允许有一个字符符合 [A-Za-z0-9] 之后可以为 [A-Za-z0-9-+.] + @ + 允许有一个字符符合 [A-Za-z0-9] 之后可以为 [A-Za-z0-9-.] + . + 允许有一个字符符合 [A-Za-z0-9] 之后可以有 [A-Za-z0-9-.] 的邮箱：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 验证身份证 18 位身份证号，尾数是数字或者字母 X：^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$ 15 或者 18 位身份证号，尾数可以是数字及 X 或者 x：(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 验证手机号 以 1 开头，第二位数是 3/4/5/7/8 的 11 位手机号码：^1[3|4|5|7|8|9]\\d{9}$ 移动号码：^134[0-8]\\d{7}$|^(?:13[5-9]|147|15[0-27-9]|178|1703|1705|1706|18[2-478])\\d{7,8}$ 电信号码：^(?:133|153|1700|1701|1702|177|173|18[019])\\d{7,8}$ 联通号码：^(?:13[0-2]|145|15[56]|176|1704|1707|1708|1709|171|18[56])\\d{7,8}|$ Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-28 18:08:46 "},"gitbook/Node-library/":{"url":"gitbook/Node-library/","title":"Node","keywords":"","body":"CSS Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/Mysql-library/":{"url":"gitbook/Mysql-library/","title":"Mysql","keywords":"","body":"CSS Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/Other-library/":{"url":"gitbook/Other-library/","title":"其他资料库","keywords":"","body":"CSS Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/Other-library/Markdown_Website/":{"url":"gitbook/Other-library/Markdown_Website/","title":"Markdown_Website","keywords":"","body":"CSS Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/Other-library/Markdown_Website/Markdown/":{"url":"gitbook/Other-library/Markdown_Website/Markdown/","title":"Markdown","keywords":"","body":"Markdown 学习 目录 一 Markdown介绍 1.1 什么是Markdown  1.2 Markdown是谁创造的？  1.3 为什么要使用Markdown 二 Markdown 语法  2.1 标题  2.2 无序列表  2.3 有序列表  2.4 区块引用  2.5 分割线  2.6 链接  2.7 图片  2.8 代码框  2.9 表格  2.10 强调  2.11 转义  2.12 删除线  2.13 缩略标签 三 结语 一 Markdown介绍 1.1 什么是Markdown？ Markdown 是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。目前 github、Stackoverflow 等网站均支持这种格式。 Markdown 文件的后缀为 .md。 1.2 Markdown是谁创造的？ 它是由 Aaron Swartz 和 John Gruber 共同设计， Aaron Swartz 就是那位（2013年1月11日）自杀，有着开挂一般人生经历的程序员。 维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。 1.3 为什么要使用Markdown? 它是易读（看起来舒服&#x1F60C;）、易写（语法简单）、易更改（纯文本）。处处体现着极简主义的影子。 兼容HTML,可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown. 更方便清晰的组织你的电子邮件。（Markdown-here,Airmail）。 摆脱Word,txt！！！ 二 Markdown 语法 2.1 标题 用法介绍：标题可以像 HTML 一样使用一级至六级标题，使用 # 即可，一级标题的使用方法为：# 一级标题，几级标题就使用几个 #。 写法 #### 四级标题 ##### 五级标题 ###### 六级标题 演示： 四级标题 五级标题 六级标题 2.2 无序列表 用法介绍：无序列表可以使用 * + - 这三种格式，这里推荐使用*：* 列表1 写法 * 列表1 + 列表2 - 列表3 演示： 列表1 列表2 列表3 2.3 有序列表 用法介绍：有序列表使用数字1. **即可，如果开始数字是3，那这个列表就从3. \\**开始，第二条是4. *** 写法 1. 列表1 2. 列表2 3. 列表3 演示： 列表1 列表2 列表3 2.4 区块引用 用法介绍：区块引用使用 > 这个符号，空格后放文本即可：> 一级区块 写法 > 注意：区块引用的左边，有个竖线！ >> 注意：引用还可以嵌套使用，这是二级的引用，二级以上相信你也懂了 >>> 注意：这是三级嵌套，相信你知道怎么用了 演示： 注意：区块引用的左边，有个竖线！ 注意：引用还可以嵌套使用，这是二级的引用，二级以上相信你也懂了 注意：这是三级嵌套，相信你知道怎么用了 2.5 分割线 用法介绍：分割线使用三个及以上的 * 或者 - 或者 _ 都可，这里使用三个 *：*** 写法 *** --- ___ 演示： 2.6 链接 介绍：链接分为行内式和参数式这两种方法 2.6.1 行内式 写法 [webmryang 的网站](https://webmryang.github.io/) 演示： webmryang 的网站 2.6.2 参数式 写法 ``` [site]:https://webmryang.github.io \"网站\" [网站]:https://webmryang.github.io \"网站\" 这里是 [site]，这里是 [网站] ``` 演示： 这里是 site，这里是 网站 2.7 图片 用法介绍： 如果是本地图片，则支持绝对路径和相对路径 如果是网络图片，则可以使用 http://** 来引入 如果是 base64，怎么使用参考 markdown 引用 base64 写法 ![图片](https://qq.yh31.com/tp/zjbq/201901182223553205.gif) 演示： 2.8 代码框 介绍：代码框分为单行用和多行用这两种方法： 2.8.1 单行用 写法 `你好使用者，要看看` 演示： 你好使用者，要看看 2.8.2 多行用 写法 ``` 你好使用者，要看看 你好使用者，要看看 ``` 演示： 你好使用者，要看看 你好使用者，要看看 2.9 表格 介绍：表格有三种表示方法： 2.9.1 第一类表格 写法 | name | age | sex | | :---: | :--- | ---: | | webmryang | 23 | 男 | | 小杨 | 23 | 男 | 演示： name age sex webmryang 23 男 小杨 23 男 2.9.2 第二类表格 写法 | name | age | sex | | --- | --- | --- | | webmryang | 23 | 男 | | 小杨 | 23 | 男 | 演示： name age sex webmryang 23 男 小杨 23 男 2.9.3 第三类表格 写法 学号 | 姓名 | 分数 - | - | - 小明 | 男 | 75 小红 | 女 | 79 小陆 | 男 | 92 演示： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 2.10 强调 2.10.1 字体倾斜 写法 *字体倾斜* _字体倾斜_ 演示： 字体倾斜 字体倾斜 2.10.2 字体加粗 写法 **字体加粗** __字体加粗__ 演示： 字体加粗 字体加粗 2.11 转义 用法介绍：通过使用\\加上特殊字符，达到转义效果。 写法 * \\\\ * \\` * \\~ * \\* * \\_ * \\- * \\+ * \\. * \\! * …… 演示： \\ ` ~ * _ - + . ! …… 2.12 删除线 用法介绍：请删除我吧。 写法 ~~请删除我吧！~~ 演示： 请删除我吧！ 2.13 缩略标签 用法介绍缩略标签属于 HTML 中的内容，但是巧妙用在 Markdown 也是可行的。 写法 基础知识 被缩略 你还需要知道其他的吗？ 演示： 基础知识 被缩略 你还需要知道其他的吗？ 三 结语 至此，Markdown 语法介绍完毕，有兴趣的小伙伴继续去了解更深层次的 Markdown 语法吧！ Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/Other-library/Markdown_Website/GitBook/":{"url":"gitbook/Other-library/Markdown_Website/GitBook/","title":"GitBook 建站","keywords":"","body":"gitbook 1.1 gitbook介绍 GitBook 是一个基于 Node.js 的命令行工具，支持 Markdown 和 AsciiDoc 两种语法格式，可以输出 HTML、PDF、eBook 等格式的电子书。所以我更喜欢把 GitBook 定义为文档格式转换工具。 市面上我们可以找到很多 Markdown 编辑器，比如 Typora、MacDown、Bear、MarkdownPad、MarkdownX、JetBrains’s IDE（需要安装插件）、Atom、简书、CSDN 以及 GitBook 自家的 GitBook Editor 等等。 但 GitBook 又与 Markdown 和 Git 息息相关，因为只有将它们结合起来使用，才能将它们的威力发挥到极致！因此，通常我们会选择合适的 Markdown 编辑工具以获得飞一般的写作体验；使用 GitBook 管理文档，预览、制作电子书；同时通过 Git 管理书籍内容的变更，并将其托管到云端（比如 GitHub、GitLab、码云，或者是自己搭建的 Git 服务器），实现多人协作。 1.2 gitbook优点 简单来说，GitBook + Markdown + Git 带来的好处有： 语法简单 兼容性强 导出方便 专注内容 团队协作 1.3 结论 当然，GitBook 不是万能的，当我们需要复杂排版时，依然需要依托于 Word 等工具。但不用担心，因为我们可以把 Markdown 格式的文档导出为 Word 格式，再进一步加工。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-28 19:42:48 "},"gitbook/Other-library/Markdown_Website/GitBook/init.html":{"url":"gitbook/Other-library/Markdown_Website/GitBook/init.html","title":"环境搭建","keywords":"","body":"GitBook 初始化 gitbook是基于 node.js的命令工具，,首先需要安装并配置好node.js 环境,然后才能安装gitbook 相关工具. 1. gitbook 环境预检查 1.1 git 环境 git 是免费开源的分布式版本控制系统,主要用于电子书的更新管理和团队协作,如果不需要将电子书托管到github 网站上,则可以不安装 git . 如果打印出 git 版本信息,则表示本机已安装 git 环境,跳过此步骤. $ git --version git 安装配置教程请参考初识 git 1.2 node.js 环境 node.js 是 js 在服务端运行的环境基础,从而使得 js 从浏览器端延伸到服务端领域,而 gitbook 则是运行在 node.js 基础之上的命令行工具,因此必须先安装好 node.js 开发环境. 如果打印出 node.js 版本信息,则表示本机已安装 node.js 环境,跳过此步骤. $ node -v node.js 安装配置教程请参考 node 2. gitbook 安装 2.1 gitbook-cli安装 gitbook-cli 是 gitbook 的脚手架工具,帮助我们更方便构建 gitbook 应用,当然也可以直接安装 gitbook ,只不过那样的话,略显麻烦,不推荐. mac 上执行 $ sudo npm install -g gitbook-cli window 上执行 $sudo npm install -g gitbook-cli 安装成功后会带有 gitbook 命令,现在再次运行下 gitbook -V 查看版本信息. # 打印出 `CLI` 和 `GitBook` 版本信息即可,安装版本可能已经大于 `2.3.2` $ gitbook -V CLI version: 2.3.2 GitBook version: 3.2.3 2.2 安装 GitBook Editor gitbook官方客户端编辑器,支持 windows, mac 和 linux ,主要用于可视化编辑文档,组织文档结构. 下载相应平台的 GitBook Editor,正常安装即可. gitbook 的使用方法大致可以有三种,而 GitBook Editor 编辑器只是其中一种,所以这一步是可选的. 使用 gitbook-cli 脚手架提供的各种命令直接在命令行管理 gitbook,适合一定编程经验的软件从业人员. 使用 GitBook Editor 编辑器管理 gitbook ,适合无任何编程的文学创作者. 使用 gitbook.com 官网在线管理 gitbook ,适合不具备本地开发环境的萌新体验者. 3. gitbook命令 3.1 常用命令 安装 GitBook：npm i gitbook-cli -g 初始化 GitBook 项目：gitbook init 安装 GitBook 依赖：gitbook install 开启 GitBook 服务：gitbook serve //gitbook serve --port 2333 指定端口 打包 GitBook 项目：gitbook build GitBook 命令行查看：gitbook -help GitBook 版本查看：gitbook -V 3.2 目录介绍 当我们执行完 npm i gitbook-cli -g 后，就开始进行gitbook开发，找一个空文件夹，初始化一个 GitBook 项目：gitbook init，目录会生成一个 README.md 内容文件和一个 SUMMARY.md 目录文件如下。 - GitBook - README.md - SUMMARY.md SUMMARY.md [链接](链接地址) 表示跳转链接，即 GitBook 会根据你的 SUMMARY 自动帮你生成左侧菜单栏的目录 README.md 书写文档，在SUMMARY中显示 最后，我们在 终端 输入 gitbook serve 即可开启一个 localhost:4000 的服务，请在浏览器中输入 http://localhost:4000 即可访问服务。 4. 总结 gitbook 基于 node.js 开发环境,因此首先要安装好 nodejs 环境,其次再使用 node.js 提供的 npm 包管理工具来安装 gitbook. 只需运行 sudo npm install -g gitbook-cli 即可安装,接着运行 gitbook -V 查看安装版本信息确认已经安装成功. 至此 gitbook 的必要开发环境已经准备妥当,接下来让我们赶紧体验一下 gitbook 的魅力吧! Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-25 17:31:47 "},"gitbook/Other-library/Markdown_Website/GitBook/plugins.html":{"url":"gitbook/Other-library/Markdown_Website/GitBook/plugins.html","title":"插件","keywords":"","body":"插件 1.book.json 配置 1.1 title 设置书本的标题 \"title\": \"webMrYang的文档库\" 1.2 author 作者的相关信息 \"author\": \"webMrYang\" 1.3 description 本书的简单描述 \"description\": \"前端一些资料\" 1.4 language Gitbook使用的语言, 版本2.6.4中可选的语言如下： en, ar, bn, cs, de, en, es, fa, fi, fr, he, it, ja, ko, no, pl, pt, ro, ru, sv, uk, vi, zh-hans, zh-tw 例如，配置使用简体中文 \"language\": \"zh-hans\" 1.5 links 在左侧导航栏添加链接信息 \"links\" : { \"sidebar\" : { \"Home\" : \"https://www.baidu.com\" } } 1.6 styles 自定义页面样式， 默认情况下各generator对应的css文件 \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } 例如使 标签有下边框， 可以在website.css中设置 h1 , h2{ border-bottom: 1px solid #EFEAEA; } 1.7 plugins 配置使用的插件 \"plugins\": [ \"-search\", \"back-to-top-button\", \"expandable-chapters-small\", \"insert-logo\" ] 其中\"-search\"中的 - 符号代表去除默认自带的插件 Gitbook默认自带有5个插件： highlight： 代码高亮 search： 导航栏查询功能（不支持中文） sharing：右上角分享功能 font-settings：字体设置（最上方的\"A\"符号） livereload：为GitBook实时重新加载 1.8 pluginsConfig 配置插件的属性 例如配置prism的属性： \"prism\": { \"css\": [ \"prismjs/themes/prism-solarizedlight.css\" ], \"lang\": { \"shell\": \"bash\" } }, 2 插件安装 用法：在book.json中添加\"plugins\"和\"pluginConfig\"字段。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-插件名，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） 2.1 back-to-top-button 回到顶部 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-back-to-top-button，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"back-to-top-button\" ] } 效果如下图所示： 2.2 expandable-chapters 导航目录折叠 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-expandable-chapters，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"expandable-chapters\" ] } 2.3 代码复制 2.3.1. code 代码添加行号&复制按钮 为代码块添加行号和复制按钮，复制按钮可关闭 单行代码无行号。 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-chapter-fold，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"code\" ] } 如果想去掉复制按钮，在book.json的插件配置块更新： { \"plugins\" : [ \"code\" ], \"pluginsConfig\": { \"code\": { \"copyButtons\": false } } } 效果如下图所示： 2.3.2. copy-code-button 代码复制按钮 为代码块添加复制的按钮。 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-copy-code-button，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"copy-code-button\" ] } 效果如下图所示： 2.4 search-pro 高级搜索（支持中文） 支持中文搜索, 在使用此插件之前，需要将默认的search和lunr 插件去掉。 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-search-pro，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"-lunr\", \"-search\", \"search-pro\" ] } 2.5 splitter 侧边栏宽度可调节 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-splitter，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"splitter\" ] } 效果如下图所示： 2.6 sharing-plus 多一些分享方式 分享当前页面，比默认的 sharing 插件多了一些分享方式。 npm仓库地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-sharing-plus { \"plugins\": [\"-sharing\", \"sharing-plus\"], \"pluginsConfig\": { \"sharing\": { \"douban\": false, \"facebook\": false, \"google\": true, \"pocket\": false, \"qq\": false, \"qzone\": true, \"twitter\": false, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\",\"twitter\", \"weibo\", \"messenger\",\"qq\", \"qzone\",\"viber\",\"whatsapp\" ] } } } 其中： 为true的代表直接显示在页面顶端，为false的不显示，不写默认为false \"all\"中代表点击分享符号显示出来的 效果如下图所示： 2.7 github 在右上角添加github图标 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-github，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"github\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/zhangjikai\" } } } 效果如下图所示： 2.8 tbfed-pagefooter 页面添加页脚 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-tbfed-pagefooter，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"tbfed-pagefooter\" ], \"pluginsConfig\": { \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy xxxx.com 2017\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } } } 效果如下图所示： 2.9 donate 打赏插件 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-donate，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"donate\" ], \"pluginsConfig\": { \"donate\": { \"wechat\": \"微信收款的二维码URL\", \"alipay\": \"支付宝收款的二维码URL\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" } } } 2.10 theme-comscore 为Table添加样式 npm地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-theme-comscore，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"theme-comscore\" ] } 效果如下图所示： 2.11 prism 为 GitBook 的 Code 添加更好看的样式 prism：为 GitBook 的 Code 添加更好看的样式，使用它的时候记得屏蔽 GitBook 默认的 highlight 插件，即通过 （-highlight 表示，下面出现 - 的插件也一样） npm地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-prism，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"prism\", \"-highlight\" ], \"pluginsConfig\": { \"prism\": { \"css\": [ \"prismjs/themes/prism-solarizedlight.css\" ], \"lang\": { \"shell\": \"bash\" } } } } 2.12 anchor-navigation-ex 生成菜单。 expandable-chapters：自动生成菜单,并跳转顶部 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-anchor-navigation-ex，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"anchor-navigation-ex\" ], \"pluginsConfig\": { \"anchor-navigation-ex\": { \"showLevel\": false } } } 效果如下图所示： 2.13 sectionx 将页面分块显示。 用于将页面分成多个部分，并添加按钮以允许读者控制每个部分的可见性。 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-sectionx，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"sectionx\" ] } 使用方式 参数 说明 data-title 该部分的标题，它将显示为bootstrap面板的标题（大小为h2）。请注意，您不能使用\"标题中的字符，请\"改用。 data-id 对按钮控制起作用。 data-show 默认表示面板内容是否可见的布尔值。true：默认情况下，面板内容对用户可见，面板标题可以单击。false：默认情况下，面板内容对用户隐藏，面板标题不可点击，只能通过添加自定义按钮查看 data-nopdf 一个布尔值，表示该部分是否将隐藏在pdf导出中。true：面板不会显示在.pdf或.epub中。 data-collapse 一个布尔值，表示默认情况下是否打开（但仍然可见）该部分。true：默认情况下，面板内容对用户可见，但已关闭。false：默认情况下，面板内容对用户隐藏，但已打开（默认设置）。 控制按钮 标签 说明 class 该按钮必须属于类“section”。 target 当按下时，将切换id为target的部分//这里就是用到上面的的data-id show 隐藏目标部分时按钮上的文本。 hide 目标部分可见时按钮上的文本。 example： 内容部分2 内容部分2 2.14 baidu-tongji 添加百度统计。 npm地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-baidu-tongji，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"baidu-tongji\" ], \"pluginsConfig\": { \"baidu-tongji\": { \"token\": \"f3f331c21843f7b950e103f51fbabc60\" } } } 2.15 favicon 更改网站的 favicon.ico。 npm地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-favicon，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"favicon\" ], \"pluginsConfig\": { \"favicon\": { \"shortcut\": \"assets/images/favicon.ico\",//首先，shortcut通常可以被所有可以显示favicon的浏览器读取。 \"bookmark\": \"assets/images/favicon.ico\",//在收藏夹中显示自己的图标 \"appleTouch\": \"assets/images/apple-touch-icon.png\",//是一个类似网站favicon的图标文件，用来在iphone和iPad上创建快捷键时使用 \"appleTouchMore\": { \"120x120\": \"assets/images/apple-touch-icon-120x120.png\", \"180x180\": \"assets/images/apple-touch-icon-180x180.png\" } } } } 2.16 待做项☑。 添加 Todo 功能。默认的 checkbox 会向右偏移 2em，如果不希望偏移，可以在 website.css 里加上下面的代码: GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-todo，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"todo\" ] } 使用示例： * [ ] write some articles * [x] drink a cup of tea [ ] write some articles [x] drink a cup of tea 2.17 Codeblock显示所包含文件的内容。 使用代码块的格式显示所包含文件的内容. 该文件必须存在。插件提供了一些配置，可以区插件官网查看。如果同时使用 ace 和本插件，本插件要在 ace 插件前面加载。 CodeblockNPM地址 aceNPM地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-include-codeblock gitbook-plugin-ace，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"include-codeblock\", 'ace' ], \"pluginsConfig\": { \"include-codeblock\": { \"template\": \"ace\", \"unindent\": \"true\", \"theme\": \"monokai\" } } } 使用示例： Example of code \\[import\\](./test.js) Example of code const arr = { \"plugins\": [ \"include-codeblock\" ], \"pluginsConfig\": { \"include-codeblock\": { \"template\": \"ace\", \"unindent\": \"true\", \"theme\": \"monokai\" } } } 2.18 gitalk 评论插件。 gitalk 利用 github 的开发者接口授权,将讨论区的 issue 变成评论区,和 github 结合的如此紧密,适合用源码托管到 github 这类情况. 我们在需要评论的页面中加入下面代码 var gitalk = new Gitalk({ \"clientID\": \"8c2f22bd64d1ea012ac5\", \"clientSecret\": \"992cdea444e1503ceac91bfd74907b37e590a159\", \"repo\": \"webmryang.github.io\", \"owner\": \"WebMrYang\", \"admin\": [\"WebMrYang\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); 字段意思： 1. `clientID` ：GitHub 开发者设置，客户端连接标识。 2. `clientSecret`：GitHub 开发者设置，客户端秘钥。 3. `repo`：GitHub 仓库名，我们的就是 document-library 啦。 4. `owner`：GitHub 仓库所有者，就是我 GitHub 账户：`LiangJunrong`。 5. `admin`：GitHub 仓库管理者，还是我的 GitHub 账户：`LiangJunrong`。（支持数组，多个管理者） 6. `id`：页面的唯一标识，默认值: `location.href` 7. `distractionFreeMode`：类似 Facebook 评论框的全屏遮罩效果,默认值: `false` [官方配置](https://github.com/gitalk/gitalk#install) GitHub开发授权应用 3 插件 - 参考文献 GitBook 搭建 GitBook插件整理 gitbook 入门教程之实用插件 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-27 15:47:10 "},"gitbook/Other-library/Markdown_Website/GitBook/build.html":{"url":"gitbook/Other-library/Markdown_Website/GitBook/build.html","title":"发布","keywords":"","body":"发布 已经写好项目，就可以进行打包，发布了 HTML:gitbook build [书籍路径] [输出路径] PDF: gitbook pdf ./ ./mybook.pdf epub gitbook epub ./ ./mybook.epub mobi gitbook mobi ./ ./mybook.mobi 然后，部署到 GitHub(教程) 上了。 最后，我们查看下我们的部署页面(地址)： Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-25 17:39:23 "},"gitbook/Other-library/Markdown_Website/GitBook/question.html":{"url":"gitbook/Other-library/Markdown_Website/GitBook/question.html","title":"开发问题记录","keywords":"","body":"GitBook 开发问题记录 1. 在使用 gitbook-cli 初始化后，使用插件后报错 gitbook serve和gitbook build都报错 Error: ENOENT: no such file or directory, stat ‘C:*demo_book_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js’ 原来是一个Bug（Vesion：3.2.3）。 https://github.com/GitbookIO/gitbook/issues/1309 解决办法如下。 1、用户目录下找到以下文件。 .gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js Replace all confirm: true with confirm: false 2、执行gitbook fetch 2.6.7 2. gitbook使用gitalk时报Error: Not Found. 这个是因为配置的gitalk中的repo配置错误，可以配置为你的用户名.github.io Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-25 17:15:17 "},"gitbook/Other-library/Markdown_Website/GitHub/":{"url":"gitbook/Other-library/Markdown_Website/GitHub/","title":"GitHub 发布","keywords":"","body":"GitHub 学习 1. 什么是 GitHub Pages？ GitHub Pages 是一个通过 GitHub 项目/仓库 进行部署的，以 username.github.io 的形式生成用户的托管平台。 通过 GitHub Pages，用户只需要把自己的内容在本地编辑好，然后推送到 GitHub 仓库即可。 2. github pages好处 使用零成本: github pages 集成在 github 中, 直接和代码管理绑定在一起, 随着代码更新自动重新部署, 使用非常方便. 免费: 免费提供 username.github.io 的域名, 免费的静态网站服务器. 无数量限制: github pages 没有使用的数量限制, 每一个 github repository 都可以部署为一个静态网站. 3. 搭建 3.1 新建仓库 打开 GitHub 页面，注册号用户后，新建仓库（New repository），在仓库名（Repository name）中输入 username.github.io，例如 webmryang 的就是：webmryang.github.io，然后点击 Create repository 即可创建一个部署好的环境。(用户名大小生成网址时都是小写) 3.2 Clone 项目 clone项目到本地： 下载的时候选择ssh下载，可以配置ssh免密登录 3.3 上传项目到 GitHub 在项目中加入一个html页面执行一下操作： ``` git add . git commit -m 'github' git push ``` 3.4 打开 用户名.github.io 打开 用户名.github.io 3.5 查看Settings 在settings中也可以查看项目在网站上的真实的网址 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-26 15:56:01 "},"gitbook/Other-library/SSH/":{"url":"gitbook/Other-library/SSH/","title":"SSH","keywords":"","body":"SSH 1. 概念 SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括、Linux以及其他平台，都可运行SSH。 2. 安全验证 SSH验证：从客户端来看，SSH提供两种级别的安全验证。 第一种级别（基于口令的安全验证） 只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。 第二种级别（基于密匙的安全验证） 需要依靠密匙，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。 用这种方式，你必须知道自己密匙的口令。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。 3. 命令 3.1 查看当前电脑所有的ssh:ls -al ~/.ssh 3.2 一台电脑上github和gitlab配置ssh 如果没有生成过.ssh文件，就要执行 $ ssh-keygen -t rsa -C \"email@email.com\" 来创建.ssh，如果当前是为github生成，使用github的邮箱，如果是gitlab则输入gitlab的邮箱; 下面你会看到下图，如果只是配置一个github或者gitlab 直接回车就可以了，如果是想同时配置则需要修改生成的id_rsa，以上面为例子，可以输入 /c/Users/Administrator/.ssh/github_id_rsa 后回车,这里的github_id_rsa你可以自己去定义 接下来直接回车就ssh的秘钥就生成了 如果是自己输入了秘钥名称则需要配置一个config文件,里面配置如下(其中.ssh目录如下) # gitlab Host gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id-rsa # github Host github.com HostName github.com # User WebMrYang PreferredAuthentications publickey IdentityFile ~/.ssh/github_id_rsa 当完成以上的ssh秘钥生成后，我们就可以给github或者gitlab来配置公钥了，公钥的后缀是.pub,复制.pub文件中的公钥，登陆你的github帐户。点击你的头像，然后 Settings -> 左栏点击 SSH and GPG keys -> 点击 New SSH key新建公钥title可以随便输key就是你刚刚新建的公钥 可以测试下 ssh git@github.com如果输出Hi xxx! You've successfully authenticated, but GitHub does not # provide shell access. Connection to github.com closed.说明成功了如图： Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-26 18:14:12 "},"gitbook/Other-library/Interview/":{"url":"gitbook/Other-library/Interview/","title":"面试","keywords":"","body":"1. 谈谈你对前端性能优化的理解 对数据进行异步加载 开启GZip，精简JavaScript，移除重复脚本，图像优化，将icon做成字体 使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 1. html部分 要避免代码的深层级嵌套。因为层级越深的节点在初始化时更占内存。 尽量不要使用h5摒弃的iframe标签，因为在页面加载的时候iframe标签会阻塞父文档onload事件的触发，这恰恰影响了初始化UI 诸如img、link、script等元素的src或href属性的值不为空，因为就算我们写为src=\"\"浏览器仍会发送http请求 为页面中的图片设置宽高，这样做的好处是在页面加载完前就完成了布局，如若未指定宽高，在图片加载后还要调整其大小，影响时间。 在html文档开始就指定文档字符集，这样做的目的是在有助于浏览器加载时就能立即解析html代码 2. css部分： 将样式表置顶，这样做的好处是文档加载完毕之前样式就已经加载完，不用等页面加载完毕后再重新加载样式 避免使用css表达式，避免重定向 使用外部css并且精简css，移除无用的css样式 用link来代替@important 3. js部分 将脚本置底，避免script标签加载的时候页面等待加载 使用外部脚本以及精简后的去除重复的脚本 尽量减少dom访问，在《高性能JavaScript》中这么比喻：“把DOM看成一个岛屿，把JavaScript(ECMAScript)看成另一个岛屿，两者之间以一座收费桥连接”。所以每次访问DOM都会教一个过桥费，而访问的次数越多，交的费用也就越多。所以一般建议尽量减少过桥次数。 使用json格式来进行数据交换，因为JSON是一种轻量级的数据交换格式，采用完全独立于语言的文本格式，是理想的数据交换格式。同时，JSON是 JavaScript原生格式，这意味着在 JavaScript 中处理 JSON数据不需要任何特殊的 API 或工具包。 2. 网站重构的理解 重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化，针对于SEO进行优化 减少代码间的耦合，让代码保持弹性 压缩或合并或拆分JS、CSS、image等前端资源 3. 对前端界面工程师这个职位是怎么样理解的？ 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术 3. 平时如何管理你的项目？ a. 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； b. 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； c. 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； d. 页面进行标注（例如 页面 模块 开始和结束）； e. CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； f. JS 分文件夹存放 命名以该JS功能为准的英文翻译。 g. 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 20.如何管理前端团队? 请自行根据自己情况做回答，这个没有标准答案。 21.最近在学什么？能谈谈你未来3，5年给自己的规划吗？ 请自行根据自己情况做回答，这个没有标准答案。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 11:39:34 "},"gitbook/Other-library/Interview/CSS/":{"url":"gitbook/Other-library/Interview/CSS/","title":"CSS","keywords":"","body":"1. 请简述盒模型 IE6盒子模型与W3C盒子模型。 文档中的每个元素被描绘为矩形盒子。盒子有四个边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。 CSS3中有个box-sizing属性可以控制盒子的计算方式， content-box：padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和。（W3C盒子模型） border-box：padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值。（IE6盒子模型） 2. 边距重叠解决方案(BFC) 首先要明确BFC是什么意思，其全英文拼写为 Block Formatting Context 直译为“块级格式化上下文” 1. BFC的原理 内部的box会在垂直方向，一个接一个的放置 每个元素的margin box的左边，与包含块border box的左边相接触（对于从做往右的格式化，否则相反） box垂直方向的距离由margin决定，属于同一个BFC的两个相邻box的margin会发生重叠 BFC的区域不会与浮动区域的box重叠 BFC是一个页面上的独立的容器，外面的元素不会影响BFC里的元素，反过来，里面的也不会影响外面的 计算BFC高度的时候，浮动元素也会参与计算 2. 怎么取创建BFC float属性不为none（脱离文档流） position为absolute或fixed display为inline-block,table-cell,table-caption,flex,inine-flex overflow不为visible 根元素 3. 应用场景 自适应两栏布局 清除内部浮动 防止垂直margin重叠 *{ margin:0; padding:0; } .top{ background: #0ff; height:100px; margin-bottom:30px; } .bottom{ height:100px; margin-top:50px; background: #ddd; } 上 margin-bottom:30px; 下 margin-top:50px; 上 margin-bottom:30px; 下 margin-top:50px; Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 10:32:12 "},"gitbook/Other-library/Interview/JS/":{"url":"gitbook/Other-library/Interview/JS/","title":"JS","keywords":"","body":"1. Cookies，Web Storage(LocalStorage,SessionStorage) Cookies：浏览器均支持，容量为4KB;Web Storage：HTML5，容量为5M Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookie Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，在每次请求一个新的页面的时候都会被发送过去；而Web Storage仅仅是为了在本地“存储”数据而生 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，是会话级别的存储；localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 每个特定的域名下最多生成的cookie个数（IE6：20;IE6以后50；chrome和Safari没有做硬性限制）有限制；IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。 可以使用HttpOnly提升Cookie安全性。httponly 不支持读写，浏览器不允许脚本操作document.cookie去更改cookie，一般情况下都应该设置这个为true，这样可以避免被XSS攻击拿到cookie 2. 使用哪些工具来测试代码的性能 JSPerf, Dromaeo 3. 一次js请求一般情况下有哪些地方会有缓存处理？ DNS缓存：短时间内多次访问某个网站，在限定时间内，不用多次访问DNS服务器。 CDN缓存：内容分发网络（人们可以在就近的代售点取火车票了，不用非得到火车站去排队） 浏览器缓存：浏览器在用户磁盘上，对最新请求过的文档进行了存储。 服务器缓存：将需要频繁访问的Web页面和对象保存在离用户更近的系统中，当再次访问这些对象的时候加快了速度。 4. AMD和CMD 规范的区别？ 查看 AMD 提前执行依赖 - 尽早执行，requireJS 是它的实现。 CMD 按需执行依赖 - 懒执行，seaJS 是它的实现 5. JavaScript 的同源策略 同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。 指一段脚本只能读取来自同一来源的窗口和文档的属性。 6. WEB应用从服务器主动推送Data到客户端有那些方式？ html5 websoket WebSocket 通过 Flash XHR长时间连接 CORS 不可见的Iframe Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 14:46:39 "},"gitbook/Other-library/Interview/HTTP/":{"url":"gitbook/Other-library/Interview/HTTP/","title":"HTTP","keywords":"","body":"1. 讲讲输入完网址按下回车，到看到网页这个过程中发生了什么 用户输入url地址，浏览器根据域名寻找IP地址 浏览器向服务器发送http请求，如果服务器段返回以301之类的重定向，浏览器根据相应头中的location再次发送请求 服务器端接受请求，获取html代码，返回给浏览器，这时的html页面代码可能是经过压缩的 浏览器接收服务器响应结果，如果有压缩则首先进行解压处理，紧接着就是页面解析渲染 DNS 解析->TCP 连接->HTTP 请求抛出->服务端处理请求，HTTP 响应返回->浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户 解析渲染该过程主要分为以下步骤： 解析HTML 构建DOM树 DOM树与CSS样式进行附着构造呈现树 布局 绘制 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 09:37:51 "},"gitbook/Other-library/Interview/Vue/":{"url":"gitbook/Other-library/Interview/Vue/","title":"Vue","keywords":"","body":"Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 08:59:17 "},"gitbook/Other-library/Interview/React/":{"url":"gitbook/Other-library/Interview/React/","title":"React","keywords":"","body":"Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 08:59:22 "}}