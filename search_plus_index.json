{"./":{"url":"./","title":"首页","keywords":"","body":"Introduction 换一台电脑打开GitBook项目居然运行不了，gitbook serve和gitbook build都报错。 Error: ENOENT: no such file or directory, stat ‘C:*demo_book_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js’ 原来是一个Bug（Vesion：3.2.3）。 https://github.com/GitbookIO/gitbook/issues/1309 解决办法如下。 用户目录下找到以下文件。 .gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js Replace all confirm: true with confirm: false gitbook fetch 2.6.7 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/updateRecord.html":{"url":"gitbook/updateRecord.html","title":"更新记录","keywords":"","body":"更新记录 换一台电脑打开GitBook项目居然运行不了，gitbook serve和gitbook build都报错。 Error: ENOENT: no such file or directory, stat ‘C:*demo_book_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js’ 原来是一个Bug（Vesion：3.2.3）。 https://github.com/GitbookIO/gitbook/issues/1309 解决办法如下。 用户目录下找到以下文件。 .gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js Replace all confirm: true with confirm: false gitbook fetch 2.6.7 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/meun.html":{"url":"gitbook/meun.html","title":"文档库目录","keywords":"","body":"文档库目录 首页 更新记录 文档库目录 留言板 CSS JavaScript Regular Node Mysql 其他资料库 Markdown_Website Markdown GitBook 建站 环境搭建 插件 发布 开发问题记录 GitHub 发布 SSH Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-26 16:06:36 "},"gitbook/messageBoard.html":{"url":"gitbook/messageBoard.html","title":"留言板","keywords":"","body":"留言板 使用gitalk来进行留言 var gitalk = new Gitalk({ \"clientID\": \"8c2f22bd64d1ea012ac5\", \"clientSecret\": \"992cdea444e1503ceac91bfd74907b37e590a159\", \"repo\": \"webmryang.github.io\", \"owner\": \"WebMrYang\", \"admin\": [\"WebMrYang\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-25 16:50:11 "},"gitbook/CSS-library/":{"url":"gitbook/CSS-library/","title":"CSS","keywords":"","body":"CSS Mysql-library Transitions, Transforms和Animation Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 15:17:41 "},"gitbook/CSS-library/Flex.html":{"url":"gitbook/CSS-library/Flex.html","title":"Flex","keywords":"","body":"一、Flex布局是什么？ Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局（行内元素也可以）。 二、基本概念 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目” 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性 以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性 flex-direction属性决定主轴的方向（即项目的排列方向）。 .box { flex-direction: row | row-reverse | column | column-reverse;} 3.2 flex-wrap属性 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse;} 3.3 flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: row nowrap ;} 3.4 justify-content属性 justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around;} 3.5 align-items属性 align-items属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch;} 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} 四、项目的属性 以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: ;} 4.2 flex-grow属性 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 .item { flex-grow: ; /* default 0 */} 4.3 flex-shrink属性 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 .item { flex-shrink: ; /* default 1 */} 4.4 flex-basis属性 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: | auto; /* default auto */} 4.5 flex属性 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ ? || ]} 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch;} 五、尝试 Document * { border: 0px; padding: 0px; margin: 0px; } .main { display: flex; height: 100vh; /* flex-direction: row; flex-wrap: wrap-reverse; */ flex-flow: row wrap-reverse; /* flex-flow: row nowrap; align-items: center ; */ justify-content: space-around; align-content: center; } .main div:first-child, .main div:last-child { height: 100px; } .main div { height: 200px; width: 100px; border: 1px solid red; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 15:42:09 "},"gitbook/CSS-library/BoxCenter.html":{"url":"gitbook/CSS-library/BoxCenter.html","title":"居中效果","keywords":"","body":"一、 圣杯 代码 css: #hd{ height:50px; background: #666; text-align: center; } #bd{ /*左右栏通过添加负的margin放到正确的位置了，此段代码是为了摆正中间栏的位置*/ padding:0 200px 0 180px; height:100px; } #middle{ float:left; width:100%;/*左栏上去到第一行*/ height:100px; background:blue; } #left{ width:180px; height:100px; background:#0c9; float:left; margin-left:-100%; /*中间栏的位置摆正之后，左栏的位置也相应右移，通过相对定位的left恢复到正确位置*/ position:relative; left:-180px; } #right{ width:200px; height:100px; background:#0c9; float:left; margin-left:-200px; /*中间栏的位置摆正之后，右栏的位置也相应左移，通过相对定位的right恢复到正确位置*/ position:relative; right:-200px; } #footer{ height:50px; background: #666; text-align: center; } html: header middle left right footer 二、双飞翼 #hd{ height:50px; background: #666; text-align: center; } #middle{ float:left; width:100%;/*左栏上去到第一行*/ height:100px; background:blue; } #left{ width:180px; height:100px; background:#0c9; float:left; margin-left:-100%; } #right{ width:200px; height:100px; background:#0c9; float:left; margin-left:-200px; } /*给内部div添加margin，把内容放到中间栏，其实整个背景还是100%*/ #inside{ margin:0 200px 0 180px; height:100px; } #footer{ clear:both; /*记得清楚浮动*/ height:50px; background: #666; text-align: center; } html: middle left right 三、区别： 了解margin和padding和position三者区别,并且对于页面具备的影响margin的100%（父元素的width）以父级为参考,如果没有父级则为body体元,position不能使得元素换行，只能在同行显示，而margin和padding确可以使得元素换行 主要是圣杯的需要把三个标签都包含，而双飞翼确不需要 圣杯需要定位，而双飞翼不需要 圣杯（主要是margin出现问题）在页面大小切换下会出现样式问题，而双飞翼确不会，只是会使得页面中间的contern越来越小（大） 四、flex布局居中 只要是使用 * { margin: 0px; border: 0px; padding: 0px; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } .box { height: 200px; width: 200px; background: yellow; } 五、定位居中 .box { height: 200px; width: 200px; position: absolute; left: 50%; top: 50%; background: yellow; transform: translate(-50%, -50%); } Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 15:47:27 "},"gitbook/CSS-library/Animation.html":{"url":"gitbook/CSS-library/Animation.html","title":"动画animation","keywords":"","body":"CSS3动画属性的区别（Transitions, Transforms和Animation） 1. 介绍 CSS3动画相关的几个属性是：transition, transform, animation；我分别理解为过渡，变换，动画。虽意义相近，但具体角色不一。 transition指过渡啦，就是从a点都b点，就像过江坐渡轮，是有时间的，是连续的，一般针对常规CSS属性；transform指变换，就那几个固定的属性：旋转啦，缩放啦，偏移啦什么的，当独立于远房亲戚transition独自使用时，效果就是很干涩机械的旋转移动。要是配合transition属性，旋转啊什么的，就会很平滑。animation最先安家于Safari浏览器，自成一家，与transition和transform有老死不相往来之感，但是要说单挑的话，animation要比transition厉害些。 2.详情 2.1 transition 其作用是：平滑的改变CSS的值。无论是点击事件，焦点事件，还是鼠标hover，只要值改变了，就是平滑的，就是动画。于是乎，只要一个整站通用的class，就可以很轻松的渐进增强地实现动画效果，超有实用价值的说。 transiton属性是下面几个属性的缩写： transition-property 指定过渡的属性值，比如transition-property:opacity就是只指定opacity属性参与这个过渡。 transition-duration 指定这个过渡的持续时间 transition-delay 延迟过渡时间 transition-timing-function 指定过渡动画缓动类型，有ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(),其中，linear线性过度，ease-in由慢到快，ease-out由快到慢，ease-in-out由慢到快在到慢 例如下面这个很简单的例子： button { background: palegreen; border: none; outline: none; width: 100px; height: 30px; cursor: pointer; position: relative; z-index: 1; } button::before { content: ''; position: absolute; z-index: -1; top: 0; bottom: 0; left: 0; right: 0; height: 0; background: red; transform-origin: center bottom; transition: transform 0.4s ease-in-out; } button:hover::before { height: 100%; transform-origin: center top; } 查看 2.2 transform transform指变换，使用过photoshop的人应该知道里面的Ctrl+T自由变换。transform就是指的这个东西，拉伸，压缩，旋转，偏移。见下面示例代码： .trans_skew { transform: skew(35deg); } .trans_scale { transform:scale(1, 0.5); } .trans_rotate { transform:rotate(45deg); } .trans_translate { transform:translate(10px, 20px); } transform属性要是加上transition的过渡特性，那可就是如虎添翼，可以产生不少美妙的火花，例如下面这个例子，关键代码如下： .trans_effect { transition:all 2s ease-in-out; } .trans_effect:hover { transform:rotate(720deg) scale(2,2); } 2.3 animations @-webkit-keyframes resize { 0% { padding: 0; } 50% { padding: 0 20px; background-color:rgba(190, 206, 235, 0.2); } 100% { padding: 0 100px; background-color:rgba(190, 206, 235, 0.9); } } .anim_box:hover { animation-name: resize; animation-duration: 1.5s; animation-iteration-count: 4; animation-direction: alternate; animation-timing-function: ease-in-out; } Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 15:42:01 "},"gitbook/CSS-library/MeasureCom.html":{"url":"gitbook/CSS-library/MeasureCom.html","title":"rem,px,em","keywords":"","body":"px、em、rem三者的联系与区别 一、px px 实际上就是像素，用PX设置字体大小时，比较稳定和精确。 px 像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。(引自CSS2.0手册) px 特点 IE无法调整那些使用px作为单位的字体大小； 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位； Firefox能够调整px和em，rem，但是有大部分的国产浏览器使用IE内核。 二、EM em 就是根据基准来缩放字体的大小。 em 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(引自CSS2.0手册) 任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。 em特点 em的值并不是固定的； em会继承父级元素的字体大小。 避免出现1.2 * 1.2= 1.44 的现象。比如:你在 #content 中声明了字体大小为1.2em，那么在声明 p 标签的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承 #content 的字体高而变为了1em=12px。 三、 REM rem 相对于根元素 ，这样就意味着，我们只需要在根元素确定一个参考值。 rem 是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。 rem特点 rem 相对单位，相对于根元素 ; 相对大小和绝对大小的优点于一身; 修改根元素就成比例地调整所有字体大小; 避免字体大小逐层复合的连锁反应. 在这里为大家提供一个px,em,rem单位转换工具,地址 四、px、em和rem 的问题： 使用 px 设置字体大小时，存在一个问题: 当用户在浏览器中浏览我们制作的Web页面时，如果改变了浏览器的缩放，这时会使用我们的Web页面布局被打破。这样对于那些关心自己网站可用性的用户来说，就是一个大问题了。因此，这时就提出了使用“em”来定义Web页面的字体。 rem 和 em 单位是由浏览器基于你的设计中的字体大小计算得到的像素值。 二者比较 em rem 单位基于 基于使用他们的元素的字体大小 基于 html 元素的字体大小。 继承 可能受任何继承的父元素字体大小影响 可以从浏览器字体设置中继承字体大小。 使用情况 使用em单位应根据组件的字体大小而不是根元素的字体大小。不使用em单位，并且需要根据浏览器的字体大小设置缩放的情况下使用rem 使用rem单位，除非你确定你需要 em 单位，包括对字体大小。 五、浏览器的兼容性 除了IE6-IE8，其它的浏览器都支持 em 和 rem 属性，px 是所有浏览器都支持。 因此为了浏览器的兼容性，可px和rem一起使用，用px来实现IE6-8下的效果，然后使用Rem来实现代浏览器的效果。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-14 17:51:44 "},"gitbook/CSS-library/Sass.html":{"url":"gitbook/CSS-library/Sass.html","title":"sass","keywords":"","body":"sass 1. sass介绍 Sass 是一个CSS预处理程序，强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。 Sass 有两种语法格式。 首先是 SCSS (Sassy CSS) —— 这种格式仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。这种格式以 .scss 作为拓展名。$font-stack: Helvetica, sans-serif body { font: 100% $font-stack } 另一种也是最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) 通常简称 \"Sass\"，是一种简化格式。它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，这种格式以 .sass 作为拓展名。$font-stack: Helvetica, sans-serif body font: 100% $font-stack 2. sass 优点 全局变量 方便嵌套，SCSS 使我们能够在样式表中拥有相同的 HTML 视觉层次结构，这样我们就可以以一种更容易理解的方式来设计样式 它能够将可重用的样式打包在一起，并允许根据需要将样式导入到另一个样式块中，从而减少代码中的冗余 3.环境搭建 sass 的安装方式有很多种，可以查看这个地址，这里我们使用查看 如果是自己本地尝试，建议使用npm //全局下载 sass npm install -g sass // 编译单个文件 sass input.scss output.css //单文件监听命令 sass --watch input.scss:output.css //如果你有很多的sass文件的目录，你也可以告诉sass监听整个目录：app和stylesheets分别为scss和生成css文件夹 sass --watch app:stylesheets 4.使用 SCSS中的@import用于将部分内容获取到其他SCSS文件中，如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。(可以将 @import 嵌套进 CSS 样式或者 @media 中) 4.1 变量($) SCSS中的变量以美元符号$开头。编译前 $color:red; .color{ $text_color: #ddd; color:$text_color; background-color: $color; .name{ color:$text_color; } } 编译后 .color { color: #ddd; background-color: red; } .color .name { color: #ddd; } 4.2 嵌套 4.2.1 Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器 编译前 #main { width: 97%; p, div { font-size: 2em; a { font-weight: bold; } } pre { font-size: 3em; } } 编译后 #main { width: 97%; } #main p, #main div { font-size: 2em; } #main p a, #main div a { font-weight: bold; } #main pre { font-size: 3em; } 4.2.2 父选择器 & 在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 & 代表嵌套规则外层的父选择器。 编译前 a { font-weight: bold; text-decoration: none; &:hover { text-decoration: underline; } body.firefox & { font-weight: normal; } } 编译后 a { font-weight: bold; text-decoration: none; } a:hover { text-decoration: underline; } body.firefox a { font-weight: normal; } & 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器 编译前 #main { color: black; &-sidebar { border: 1px solid; } } 编译后 #main { color: black; } #main-sidebar { border: 1px solid; } 4.3 插值语句 #{} 通过 #{} 插值语句可以在选择器或属性名中使用变量： 编译前 $name: foo; $attr: border; p.#{$name} { #{$attr}-color: blue; } 编译后 p.foo { border-color: blue; } 4.4 变量定义 !default 可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。 编译前 $content: \"First content\"; $content: \"Second content?\" !default; $new_content: null; $new_content: \"First time reference\" !default; .main { content: $content; new-content: $new_content; } 编译后 .main { content: \"First content\"; new-content: \"First time reference\"; } 4.5 Mixins(使用 @include 引入) SCSS 的另一个了不起的特性是它能够将可重用的样式打包在一起，并允许根据需要将样式导入到另一个样式块中，从而减少代码中的冗余。但是相同的代码被引入了多次 编译前 @mixin button{ font-size: 1em; padding: 0.5em 1.0em; } @mixin back($back:red){ text-align: center; background-color: $back; } .button-green{ @include button; @include back(green); } .button-red{ @include button; @include back; } 编译后 .button-green { font-size: 1em; padding: 0.5em 1em; text-align: center; background-color: green; } .button-red { font-size: 1em; padding: 0.5em 1em; text-align: center; background-color: red; } 4.6 @extend 使用相同样式，基础类会被引入，并且编译后合并在一起 编译前 .icon { transition: background-color ease .2s; margin: 0 .5em; } .error-icon { @extend .icon; } .info-icon { @extend .icon; } 编译后 .icon, .info-icon, .error-icon { transition: background-color ease 0.2s; margin: 0 0.5em; } 4.6 占位符（%） %变量不会进行编译，只是会引用 编译前 %icon { transition: background-color ease .2s; margin: 0 .5em; } .error-icon { @extend %icon; } .info-icon { @extend %icon; } #context a%extreme { color: blue; font-weight: bold; font-size: 2em; } .notice { @extend %extreme; } 编译后 .info-icon, .error-icon { transition: background-color ease 0.2s; margin: 0 0.5em; } #context a.notice { color: blue; font-weight: bold; font-size: 2em; } 4.7 控制流条件样式 4.7.1 if() if() 是 Sass 的一个内建函数，与之相似的 @if 则是一个内建指令。if() 用来做条件判断并返回特定值 编译前 @mixin test($condition) { $color: if($condition, blue, red); color:$color } .firstClass { @include test(true); } .secondClass { @include test(false); } 编译后 .firstClass { color: blue; } .secondClass { color: red; } @if达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码 编译前 $type: monster; p { @if $type == ocean { color: blue; } @else if $type == matador { color: red; } @else if $type == monster { color: green; } @else { color: black; } } 编译后 p { color: green; } 4.7.2 @for @for 指令常用于循环输出。@for 有两种使用方式：from start through end 和 from start to end，两者的区别在于，前者遍历的范围是 [start, end], 而后者的遍历范围是 [start, end-1] 编译前 @for $i from 1 through 4 { .col-#{$i} { width: 100/4 * $i + '%'; } } @for $i from 1 to 4 { .span-#{$i} { width: 100/4 * $i + '%'; } } 编译后 col-1 { width: \"25%\"; } .col-2 { width: \"50%\"; } .col-3 { width: \"75%\"; } .col-4 { width: \"100%\"; } .span-1 { width: \"25%\"; } .span-2 { width: \"50%\"; } .span-3 { width: \"75%\"; } 4.7.3 @each @each 指令的格式是 $var in , $var 可以是任何变量名，比如 $length 或者 $name，而 是一连串的值，也就是值列表。 编译前 @each $animal in puma, sea-slug, egret, salamander { .#{$animal}-icon { background-image: url('/images/#{$animal}.png'); } } 编译后 .puma-icon { background-image: url(\"/images/puma.png\"); } .sea-slug-icon { background-image: url(\"/images/sea-slug.png\"); } .egret-icon { background-image: url(\"/images/egret.png\"); } .salamander-icon { background-image: url(\"/images/salamander.png\"); } 4.8 函数指令 Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用： 编译前 $grid-width: 40px; $gutter-width: 10px; @function grid-width($n) { @return $n * $grid-width + ($n - 1) * $gutter-width; } #sidebar { width: grid-width(5); } 编译后 #sidebar { width: 240px; } 5. 区别 4.4@mixin，4.5@extend，4.5占位符%中可以看出三者编译后结果的不同，具体查看sass中的占位符%，@extend，@mixin（@include）的编译区别和使用场景 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-08 17:49:48 "},"gitbook/JavaScript-library/":{"url":"gitbook/JavaScript-library/","title":"JavaScript","keywords":"","body":"CSS Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/JavaScript-library/Object/":{"url":"gitbook/JavaScript-library/Object/","title":"对象","keywords":"","body":"Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 14:35:47 "},"gitbook/JavaScript-library/Object/Create.html":{"url":"gitbook/JavaScript-library/Object/Create.html","title":"创建","keywords":"","body":"JavaScript 创建对象的6种方式 一、工厂模式 function createPerson(name, job) { var o = new Object() o.name = name o.job = job o.sayName = function() { console.log(this.name) } return o } var person1 = createPerson('Jiang', 'student') var person2 = createPerson('X', 'Doctor') 可以无数次调用这个工厂函数，每次都会返回一个包含两个属性和一个方法的对象 工厂模式虽然解决了创建多个相似对象的问题，但是没有解决对象识别问题，即不能知道一个对象的类型 二、构造函数模式 function Person(name, job) { this.name = name this.job = job this.sayName = function() { console.log(this.name) } } var person1 = new Person('Jiang', 'student') var person2 = new Person('X', 'Doctor') 没有显示的创建对象，使用new来调用这个构造函数，使用new后会自动执行如下操作 创建一个新对象 这个新对象会被执行[[prototype]]链接 这个新对象会绑定到函数调用的this 返回这个对象 使用这个方式创建对象可以检测对象类型 person1 instanceof Object // true person1 instanceof Person //true 但是使用构造函数创建对象，每个方法都要在每个实例上重新创建一次 三、原型模式 function Person() { } Person.prototype.name = 'Jiang' Person.prototype.job = 'student' Person.prototype.sayName = function() { console.log(this.name) } var person1 = new Person() 将信息直接添加到原型对象上。使用原型的好处是可以让所有的实例对象共享它所包含的属性和方法，不必在构造函数中定义对象实例信息。 更简单的写法 function Person() { } Person.prototype = { name: 'jiang', job: 'student', sayName: function() { console.log(this.name) } } var person1 = new Person() 将Person.prototype设置为等于一个以对象字面量形式创建的对象，但是会导致.constructor不在指向Person了。 使用这种方式，完全重写了默认的Person.prototype对象，因此 .constructor也不会存在这里 Person.prototype.constructor === Person // false 如果需要这个属性的话，可以手动添加 function Person() { } Person.prototype = { constructor：Person name: 'jiang', job: 'student', sayName: function() { console.log(this.name) } } 不过这种方式还是不够好，应为constructor属性默认是不可枚举的，这样直接设置，它将是可枚举的。所以可以时候，Object.defineProperty方法 Object.defineProperty(Person.prototype, 'constructor', { enumerable: false, value: Person }) 缺点 使用原型，所有的属性都将被共享，这是个很大的优点，同样会带来一些缺点 原型中所有属性实例是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性也勉强可以，毕竟实例属性可以屏蔽原型属性。但是引用类型值，就会出现问题了 function Person() { } Person.prototype = { name: 'jiang', friends: ['Shelby', 'Court'] } var person1 = new Person() var person2 = new Person() person1.friends.push('Van') console.log(person1.friends) //[\"Shelby\", \"Court\", \"Van\"] console.log(person2.friends) //[\"Shelby\", \"Court\", \"Van\"] console.log(person1.friends === person2.friends) // true friends存在与原型中，实例person1和person2指向同一个原型，person1修改了引用的数组，也会反应到实例person2中 四、组合使用构造函数模式和原型模式 这是使用最为广泛、认同度最高的一种创建自定义类型的方法。它可以解决上面那些模式的缺点 使用此模式可以让每个实例都会有自己的一份实例属性副本，但同时又共享着对方法的引用 这样的话，即使实例属性修改引用类型的值，也不会影响其他实例的属性值了 function Person(name) { this.name = name this.friends = ['Shelby', 'Court'] } Person.prototype.sayName = function() { console.log(this.name) } var person1 = new Person() var person2 = new Person() person1.friends.push('Van') console.log(person1.friends) //[\"Shelby\", \"Court\", \"Van\"] console.log(person2.friends) // [\"Shelby\", \"Court\"] console.log(person1.friends === person2.friends) //false 五、动态原型模式 动态原型模式将所有信息都封装在了构造函数中，初始化的时候，通过检测某个应该存在的方法时候有效，来决定是否需要初始化原型 function Person(name, job) { // 属性 this.name = name this.job = job // 方法 if(typeof this.sayName !== 'function') { Person.prototype.sayName = function() { console.log(this.name) } } } var person1 = new Person('Jiang', 'Student') person1.sayName() 只有在sayName方法不存在的时候，才会将它添加到原型中。这段代码只会初次调用构造函数的时候才会执行。 此后原型已经完成初始化，不需要在做什么修改了 这里对原型所做的修改，能够立即在所有实例中得到反映 其次，if语句检查的可以是初始化之后应该存在的任何属性或方法，所以不必用一大堆的if语句检查每一个属性和方法，只要检查一个就行 六、寄生构造函数模式 这种模式的基本思想就是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新建的对象 function Person(name, job) { var o = new Object() o.name = name o.job = job o.sayName = function() { console.log(this.name) } return o } var person1 = new Person('Jiang', 'student') person1.sayName() 这个模式，除了使用new操作符并把使用的包装函数叫做构造函数之外，和工厂模式几乎一样 构造函数如果不返回对象，默认也会返回一个新的对象，通过在构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 15:15:22 "},"gitbook/JavaScript-library/Object/Inherit.html":{"url":"gitbook/JavaScript-library/Object/Inherit.html","title":"继承","keywords":"","body":"js的继承 一、比较 面向对象的继承方式有很多种，原型链继承、借用构造函数继承、组合继承、原型式继承、寄生式继承、寄生式组合继承、深拷贝继承等等。 二、方法 2.1 原型式继承 function createObjWithObj(obj){ // * 传入一个原型对象 function Temp(){} Temp.prototype = obj let o = new Temp() return o } // * 把Person的原型对象当做temp的原型对象 let temp = createObjWithObj(Person.prototype) // * 也可以使用Object.create实现 // * 把Person的原型对象当做temp2的原型对象 let temp2 = Object.create(Person.prototype) 本质上createObjWithObj() 对传入其中的对象执行了一次浅复制，将构造函数 F 的原型直接指向传入的对象。 缺点 原型中引用类型值会被修改 无法传递参数 2.2 寄生式继承 // 寄生式继承 // 我们在原型式的基础上，希望给这个对象新增一些属性方法 // 那么我们在原型式的基础上扩展 function createNewObjWithObj(obj) { let o = createObjWithObj(obj) o.name = \"邵威儒\" o.age = 28 return o } 函数的主要作用是为构造函数新增属性和方法，以增强函数。 缺点（同原型式继承）： 原型中引用类型值会被修改 无法传递参数 3.3 借助构造函数继承 通过这样的方式，会有一个问题，原型对象类似一个共享库，所有实例共享原型对象同一个属性方法，如果原型对象上有引用类型，那么会被所有实例共享，也就是某个实例更改了，则会影响其他实例，我们可以看一下 function Person(name,pets){ // * 父构造函数接收name，pets参数 this.name = name // * 赋值到this上 this.pets = pets // * 赋值到this上 } Person.prototype.eat = function(){ console.log('吃饭') } function Student(num,name,pets){ // * 在子构造函数中也接收参数 Person.call(this,name,pets) // * 在这里把name和pets传参数 this.num = num // * 赋值到this上 } let student = new Student(\"030578000\",\"邵威儒\",[\"旺财\",\"小黄\"]) 2.4 原型链继承 利用原型链的特性，当在自身找不到时，会沿着原型链往上找。 function Person(){ this.name = '邵威儒' this.pets = ['旺财','小黄'] } Person.prototype.eat = function(){ console.log('吃饭') } function Student(){ this.num = \"030578000\" } // * new一个Person的实例，同时拥有其实例属性方法和原型属性方法 let p = new Person() // * 把Student的原型对象指向实例p Student.prototype = p // * 把Student的原型对象的constructor指向Student，解决类型判断问题 Student.prototype.constructor = Student let student = new Student() console.log(student.num) // '030578000' console.log(student.name) // * '邵威儒' console.log(student.pets) // * '[ '旺财', '小黄' ]' student.eat() // '吃饭' 此时关系图为 2.5 组合继承 利用构造继承和原型链组合 function Person(name,pets){ // * 父构造函数接收name，pets参数 this.name = name // * 赋值到this上 this.pets = pets // * 赋值到this上 } Person.prototype.eat = function(){ console.log('吃饭') } function Student(num,name,pets){ // * 在子构造函数中也接收参数 Person.call(this,name,pets) // * 在这里把name和pets传参数 this.num = num // * 赋值到this上 } let p = new Person() Student.prototype = p Student.prototype.constructor = Student let student = new Student(\"030578000\",\"邵威儒\",[\"旺财\",\"小黄\"]) let student2 = new Student(\"030578001\",\"iamswr\",[\"小红\"]) console.log(student.num) // '030578000' console.log(student.name) // '邵威儒' console.log(student.pets) // '[ '旺财', '小黄' ]' student.eat() // '吃饭' student.pets.push('小红') console.log(student.pets) // * [ '旺财', '小黄', '小红' ] console.log(student2.pets) // * [ '小红' ] 这样我们就可以在子构造函数中给父构造函数传参了，而且我们也发现上图中，2个红圈的地方，代码是重复了，那么接下来我们怎么解决呢？ 能否在子构造函数设置原型对象的时候，只要父构造函数的原型对象属性方法呢？ 当然是可以的，接下来我们讲寄生式组合继承，也是目前程序猿认为解决继承问题最好的方案 2.6 寄生式组合继承 function Person(name,pets){ this.name = name this.pets = pets } Person.prototype.eat = function(){ console.log('吃饭') } function Student(num,name,pets){ Person.call(this,name,pets) this.num = num } // * 寄生式继承 function Temp(){} // * 声明一个空的构造函数，用于桥梁作用 Temp.prototype = Person.prototype // * 把Temp构造函数的原型对象指向Person的原型对象 let temp = new Temp() // * 用构造函数Temp实例化一个实例temp Student.prototype = temp // * 把子构造函数的原型对象指向temp temp.constructor = Student // * 把temp的constructor指向Student或者改成Student.prototype.constructor =Student let student1 = new Student('030578001','邵威儒',['旺财','小黄']) console.log(student1) // Student { name: '邵威儒', pets: [ '旺财', '小黄' ],num: '030578001' } let student2 = new Student('030578002','iamswr',['小红']) console.log(student2) // Student { name: 'iamswr', pets: [ '小红' ],num: '030578002' } 至此为止，我们就完成了寄生式组合继承了，主要逻辑就是用一个空的构造函数，来当做桥梁，并且把其原型对象指向父构造函数的原型对象，并且实例化一个temp，temp会沿着这个原型链，去找到父构造函数的原型对象 2.7 Class继承 Class 可以通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 class staff { constructor(){ this.company = \"ABC\"; this.test = [1,2,3]; } companyName(){ return this.company; } } class employee extends staff { constructor(name,profession){ super(); this.employeeName = name; this.profession = profession; } } // 将父类原型指向子类 let instanceOne = new employee(\"Andy\", \"A\"); let instanceTwo = new employee(\"Rose\", \"B\"); instanceOne.test.push(4); // 测试 console.log(instanceTwo.test); // [1,2,3] console.log(instanceOne.companyName()); // ABC // 通过 Object.getPrototypeOf() 方法可以用来从子类上获取父类 console.log(Object.getPrototypeOf(employee) === staff) // 通过 hasOwnProperty() 方法来确定自身属性与其原型属性 console.log(instanceOne.hasOwnProperty('test')) // true // 通过 isPrototypeOf() 方法来确定原型和实例的关系 console.log(staff.prototype.isPrototypeOf(instanceOne)); // true super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象。 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。 只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有 super 方法才能返回父类实例。 super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即super 内部的 this 指的是 B，因此 super() 在这里相当于 A.prototype.constructor.call(this) ES5 和 ES6 实现继承的区别 ES5 的继承，实质是先创造子类的实例对象 this ，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。 ES6 的继承机制完全不同，实质是先创造父类的实例对象 this （所以必须先调用 super() 方法），然后再用子类的构造函数修改 this。 2.8 深拷贝继承 // 方法一：利用JSON.stringify和JSON.parse // 这种方式进行深拷贝，只针对json数据这样的键值对有效 // 对于函数等等反而无效，不好用，接着继续看方法二、三。 // 方法二： function deepCopy(fromObj,toObj) { // 深拷贝函数 // 容错 if(fromObj === null) return null // 当fromObj为null if(fromObj instanceof RegExp) return new RegExp(fromObj) // 当fromObj为正则 if(fromObj instanceof Date) return new Date(fromObj) // 当fromObj为Date toObj = toObj || {} for(let key in fromObj){ // 遍历 if(typeof fromObj[key] !== 'object'){ // 是否为对象 toObj[key] = fromObj[key] // 如果为原始数据类型，则直接赋值 }else{ toObj[key] = new fromObj[key].constructor // 如果为object，则new这个object指向的构造函数 deepCopy(fromObj[key],toObj[key]) // 递归 } } return toObj } let dog = { name:\"小白\", sex:\"公\", firends:[ { name:\"小黄\", sex:\"母\" } ] } let dogcopy = deepCopy(dog) // 此时我们把dog的属性进行修改 dog.firends[0].sex = '公' console.log(dog) // { name: '小白', sex: '公', firends: [ { name: '小黄', sex: '公' }] } // 当我们打印dogcopy，会发现dogcopy不会受dog的影响 console.log(dogcopy) // { name: '小白',sex: '公',firends: [ { name: '小黄', sex: '母' } ] } Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 16:00:51 "},"gitbook/JavaScript-library/Object/Instance.html":{"url":"gitbook/JavaScript-library/Object/Instance.html","title":"构造函数、原型对象实例","keywords":"","body":"构造函数、原型对象实例 一、原型对象实例 每一个函数，都有一个 prototype 属性 所有的引用类型默认都是继承 Object 。 Object.prototype.__proto__ === null; Object.prototype===Object.__proto__.__proto__; Function.prototype===Function.__proto__===Object.__proto__ ; Function.prototype.__proto__ === Object.prototype; p代表__proto__ ， No.2=ƒ () { [native code] } , No.1=[constructor: ƒ, concat: ƒ, find: ƒ, findIndex: ƒ, pop: ƒ, …] 二、构造函数、原型对象、实例之间的关系 三、new 的过程 新生成了一个对象 链接到原型 绑定 this 返回新对象 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 14:58:59 "},"gitbook/JavaScript-library/Array/":{"url":"gitbook/JavaScript-library/Array/","title":"数组","keywords":"","body":"1. 扁平化处理 2. 类数组转化成数组 3. 将一组值，转换为数组 4. ES6 copyWithin() find() 和 findIndex() fill entries()，keys() 和 values() includes() flatMap() 空位 数组的空位指，数组的某一个位置没有任何值。比如，Array 构造函数返回的数组都是空位,空位不是 undefined 。 Array(3) // [, , ,] forEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 Array.from 方法会将数组的空位，转为 undefined ，也就是说，这个方法不会忽略空位。 扩展运算符（...）也会将空位转为 undefined 。 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 for...of 循环也会遍历空位。 fill() 会将空位视为正常的数组位置。 copyWithin()会连空位一起拷贝。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-06 18:06:49 "},"gitbook/JavaScript-library/Array/Flat.html":{"url":"gitbook/JavaScript-library/Array/Flat.html","title":"扁平化","keywords":"","body":"数组扁平化 1.原生flat方法 function flat(arr) { return arr.flat(Infinity); } 2.循环 function flat(arr) { const stack = [...arr]; const res = []; while (stack.length) { const first = stack.shift(); if (Array.isArray(first)) { stack.unshift(...first); } else { res.push(first); } } return res; } 3.正则处理 let ary = [1, [2, [3, [4, 5]]], 6]; function flat(arr){ let str = JSON.stringify(arr); return str.replace(/\\[|\\]/g, '').split(','); } 4.reduce实现 function flat(arr) { if (!Array.isArray(arr)) return arr; return arr.reduce((prev, val) => { return prev.concat(flat(val)); }, []); } Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-06 14:01:08 "},"gitbook/JavaScript-library/Array/ConVersion.html":{"url":"gitbook/JavaScript-library/Array/ConVersion.html","title":"类数组转化","keywords":"","body":"类数组转化成数组 ES5 [].slice.call() ES6 Array.from Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map） let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3 }; // ES5的写法 var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c'] // ES6的写法 let arr2 = Array.from(arrayLike); // ['a Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 Array.from(arrayLike, x => x * x); // 等同于 Array.from(arrayLike).map(x => x * x); Array.from([1, 2, 3], (x) => x * x) //下面的例子将数组中布尔值为false的成员转为0。 Array.from([1, , 2, , 3], (n) => n || 0) //如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 Array.from([1, , 2, , 3],function(n) {return n || this.a},{a:2} ) Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\\uFFFF的 Unicode 字符，算作两个字符的 bug。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-06 18:12:18 "},"gitbook/JavaScript-library/Array/StringToArr.html":{"url":"gitbook/JavaScript-library/Array/StringToArr.html","title":"数值转化数组","keywords":"","body":"将一组值，转换为数组 ES5 Array() ES6 Array.of() Array.of 主要目的，是弥补数组构造函数 Array() 的不足。因为参数个数的不同，会导致 Array() 的行为有差异 Array() // [] Array(undefined) // [undefined] Array(3) // [, , ,] Array(3, 11, 8) // [3, 11, 8] Array.of() // [] Array.of(undefined) // [undefined] Array.of(3) // [3] Array.of(3, 11, 8) // [3,11,8] Array 方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array() 才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。` Array.of 方法可以用下面的代码模拟实现。 function ArrayOf(){ return [].slice.call(arguments); } Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-06 18:17:47 "},"gitbook/JavaScript-library/Array/ES5.html":{"url":"gitbook/JavaScript-library/Array/ES5.html","title":"ES5方法","keywords":"","body":"Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-06 18:10:04 "},"gitbook/JavaScript-library/Array/ES6.html":{"url":"gitbook/JavaScript-library/Array/ES6.html","title":"ES6方法","keywords":"","body":"ES6 1. copyWithin() 数组实例的 copyWithin() 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。 这三个参数都应该是数值，如果不是，会自动转为数值。 // 将3号位复制到0号位 [1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5] // -2相当于3号位，-1相当于4号位 [1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5] 2. find() 和 findIndex() 数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined 。 1, 4, -5, 10].find((n) => n 数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 [1, 5, 10, 15].findIndex(function(value, index, arr) { return value > 9; }) 这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 [NaN].indexOf(NaN) // -1 [NaN].findIndex(y => Object.is(NaN, y)) // 0 // indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。 function f(v){ return v > this.age; } let person = {name: 'John', age: 20}; [10, 12, 26, 15].find(f, person); 3. fill fill 方法使用给定值，填充一个数组。 ['a', 'b', 'c'].fill(7) // [7, 7, 7] new Array(3).fill(7) // [7, 7, 7] fill 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 ['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 4. entries()，keys() 和 values() keys() 是对键名的遍历、values() 是对键值的遍历，entries() 是对键值对的遍历。 for (let index of ['a', 'b'].keys()) { console.log(index); } // 0 // 1 for (let elem of ['a', 'b'].values()) { console.log(elem); } // 'a' // 'b' for (let [index, elem] of ['a', 'b'].entries()) { console.log(index, elem); } // 0 \"a\" // 1 \"b\" 5. includes() Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。ES2016 引入了该方法 [1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false [1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 [1, 2, 3].includes(3, 3); // false [1, 2, 3].includes(3, -1); // true 6. flatMap() flatMap() 方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map() ），然后对返回值组成的数组执行 flat() 方法。该方法返回一个新数组，不改变原数组,只能展开一层数组。 flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。 // 相当于 [[2, 4], [3, 6], [4, 8]].flat() [2, 3, 4].flatMap((x) => [x, x * 2]) // [2, 4, 3, 6, 4, 8] 7. ES6中for…of与for…in的区别 for…of循环可以代替数组实例的forEach方法，不同于forEach方法，它可以与break、continue和return配合使用。 for…in循环主要是为遍历对象而设计的，不适用于遍历数组。 JavaScript 原有的for…in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for…of循环，允许遍历获得键值。 for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for…in循环也不一样。 对于普通的对象，for…of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for…in循环依然可以用来遍历键名。对于字符串来说，for…of循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。for…of循环可用于字符串、DOM NodeList 对象、arguments对象。 并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。 对于普通的对象，for…in循环可以遍历键名，for…of循环会报错。 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。 另一个方法是使用 Generator 函数将对象重新包装一下。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-06 18:14:17 "},"gitbook/JavaScript-library/ThisDirection.html":{"url":"gitbook/JavaScript-library/ThisDirection.html","title":"this指向","keywords":"","body":"this 指向问题 JS中 this 的指向不同于其他语言，JS中的 this 不是指向定义他的位置，而是在哪调用它它就指向哪里。 JS中，普通的函数调用方式有三种：直接调用、方法调用和 new 调用。除此之外，还有一些特殊的调用方式，比如通过 bind() 将函数绑定到对象之后再进行调用、通过 call()、apply()进行调用等。而 es6 引入了箭头函数之后，箭头函数调用时，其 this 指向又有所不同。下面就来分析这些情况下的 this 指向。 一、 直接调用 首先来看直接调用，就是通过 函数名(...) 这种方式调用。这时候，函数内部的 this 指向全局对象，在浏览器中全局对象是 window，在 NodeJs 中全局对象是 global。 // 简单兼容浏览器和 NodeJs 的全局对象 const _global = typeof window === \"undefined\" ? global : window; function test() { console.log(this === _global); // true } test(); // 直接调用 注意！！！直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过 函数名(...) 来对函数进行调用的方式，都称为直接调用 1.1 bind() 对直接调用的影响 这种情况在 react 和 ES6 中经常会遇到，绑定事件其实类似于之前的 var that = this; Function.prototype.bind() 的作用是将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，其 this 始终指向绑定的对象 const obj = {}; function test() { console.log(this === obj); } const testObj = test.bind(obj); test(); // false testObj(); // true 那么 可能有人会问 bind 做了什么，别着急 往下看 const obj = {}; function test() { console.log(this === obj); } // 自定义的函数，模拟 bind() 对 this 的影响 function myBind(func, target) { return function () { return func.apply(target, arguments); }; } const testObj = myBind(test, obj); test(); // false testObj(); // true 从上面的示例可以看到，首先，通过闭包，保持了 target ，即绑定的对象；然后在调用函数的时候，对原函数使用了 apply 方法来指定函数的 this 。当然原生的bind() 实现可能会不同，而且更高效。但这个示例说明了 bind() 的可行性。 1.2 call 和 apply 对 this 的影响 上面用到了 Function.prototype.apply()，与之类似的还有 Function.prototype.call()。它们的第一个参数都是指定函数运行时其中的 this 指向。 不过使用 apply 和 call 的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那 apply 和 call 不会像预期那样执行，比如 const obj = {}; function test() { console.log(this === obj); } // 绑定到一个新对象，而不是 obj const testObj = test.bind({}); test.apply(obj); // true // 期望 this 是 obj，即输出 true // 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false testObj.apply(obj); // false 二、方法调用 方法调用是指通过对象来调用其方法函数，它是对象方法、函数(...) 这样的调用形式。这种情况下，函数中的 this 指向调用该方法的对象。但是，同样需要注意 bind() 的影响。 // 第一种方式，定义对象的时候定义其方法 const obj = { test() { console.log(this === obj); } }; // 第二种方式，对象定义好之后为其附加一个方法(函数表达式) obj.test2 = function() { console.log(this === obj); }; // 第三种方式和第二种方式原理相同 // 是对象定义好之后为其附加一个方法(函数定义) function t() { console.log(this === obj); } obj.test3 = t; // 这也是为对象附加一个方法函数 // 但是这个函数绑定了一个不是 obj 的其它对象 obj.test4 = (function() { console.log(this === obj); }).bind({}); obj.test(); // true obj.test2(); // true obj.test3(); // true // 受 bind() 影响，test4 中的 this 指向不是 obj obj.test4(); // false 这里需要注意的是，后三种方式都是预定定义函数，再将其附加给 obj 对象作为其方法。再次强调，函数内部的 this 指向与定义无关，受调用方式的影响。 2.1 方法中 this 指向全局对象的情况 注意这里说的是方法中而不是方法调用中。方法中的 this 指向全局对象，如果不是因为 bind()，那就一定是因为不是用的方法调用方式，比如 const obj = { test() { console.log(this === obj); } }; const t = obj.test; t(); // false t 就是 obj 的 test 方法，但是 t() 调用时，其中的 this 指向了全局。 之所以要特别提出这种情况，主要是因为常常将一个对象方法作为回调传递给某个函数之后，却发现运行结果与预期不符——因为忽略了调用方式对 this 的影响。 三、new 调用 在 es6 之前，每一个函数都可以当作是构造函数，通过 new 调用来产生新的对象(函数内无特定返回值的情况下)。而 es6 改变了这种状态，虽然 class 定义的类用 typeof 运算符得到的仍然是 \"function\"，但它不能像普通函数一样直接调用；同时，class 中定义的方法函数，也不能当作构造函数用 new 来调用。 而在 es5 中，用 new 调用一个构造函数，会创建一个新对象，而其中的 this 就指向这个新对象。这没有什么悬念，因为 new 本身就是设计来创建新对象的。 var data = \"Hi\"; // 全局变量 function AClass(data) { this.data = data; } var a = new AClass(\"Hello World\"); console.log(a.data); // Hello World console.log(data); // Hi var b = new AClass(\"Hello World\"); console.log(a === b); // false 四、箭头函数中的 this 先来看看 MDN 上对箭头函数的说明 An arrow function expression has a shorter syntax than a function expression and does not bind its own this, arguments,super, or new.target. Arrow functions are always anonymous. These function expressions are best suited for non-method functions, and they cannot be used as constructors. 这里已经清楚了说明了，箭头函数没有自己的 this 绑定。箭头函数中使用的 this，其实是直接包含它的那个函数或函数表达式中的 this。比如 const obj = { test() { const arrow = () => { // 这里的 this 是 test() 中的 this， // 由 test() 的调用方式决定 console.log(this === obj); }; arrow(); }, getArrow() { return () => { // 这里的 this 是 getArrow() 中的 this， // 由 getArrow() 的调用方式决定 console.log(this === obj); }; } }; obj.test(); // true const arrow = obj.getArrow(); arrow(); // true 示例中的两个 this 都是由箭头函数的直接外层函数(方法)决定的，而方法函数中的 this 是由其调用方式决定的。上例的调用方式都是方法调用，所以 this 都指向方法调用的对象，即 obj。 diameter是普通函数，里面的this指向直接调用它的对象obj。perimeter是箭头函数，this应该指向上下文函数this的指向，这里上下文没有函数对象，就默认为window，而window里面没有radius这个属性，就返回为NaN。 const obj = { radius: 10, diameter() { return this.radius * 2 }, perimeter: () => 2 * Math.PI * this.radius } console.log(obj.diameter()) // 20 console.log(obj.perimeter()) // NaN 五、example var x = 20; var b={ x:10, } var a = { x: 15, fn: function () { var x = 30; return function () { return this.x } }, test: function () { setTimeout(function () { console.log(this.x) }, 500); }, test2: function () { setTimeout(() => { console.log(this.x) }, 500); }, } console.log(a.fn()); console.log((a.fn())()); console.log(a.fn()()); console.log(a.fn()() == (a.fn())()); console.log(a.fn().call(this)); console.log(a.test()); console.log(a.test2()); 答案 console.log(a.fn()); 对象调用方法，返回了一个方法。 function() {return this.x} console.log((a.fn())()); a.fn()返回的是一个函数，()()这是自执行表达式。this -> window 20 console.log(a.fn()()); a.fn()相当于在全局定义了一个函数，然后再自己调用执行。this -> window 20 console.log(a.fn()() == (a.fn())()); true console.log(a.fn().call(this)); 这段代码在全局环境中执行，this -> window 20 console.log(a.fn().call(a)); this -> a 15 console.log(a.test()); this -> window 20 console.log(a.test2()); this -> a 15 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-29 14:30:42 "},"gitbook/JavaScript-library/ToString.html":{"url":"gitbook/JavaScript-library/ToString.html","title":"toString","keywords":"","body":"toString作用 返回值： toString() 函数的返回值为 Sring 类型,返回当前对象的字符串形式。 JavaScript 的许多内置对象都重新了盖函数，来实现自身的功能需要。 类型 行为描述 Array 将数组的每个元素转化为字符串，并将他们之间用英文逗号连接起来 Boolean 如果布尔值是true，则返回“true”，否则返回“false” Function 当 name 是一个函数的名称，调用toString方法时返回\"function name(){}\" String 返回string的值 Number 返回数组的字符串表示 Object 返回\"[object ObjectName]\" 其中 ObjectName是对象类型的名称， Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 15:49:04 "},"gitbook/JavaScript-library/PointChange.html":{"url":"gitbook/JavaScript-library/PointChange.html","title":"bind,apply,call","keywords":"","body":"一、bind、apply与call三者区别 在JS中，这三者都是用来改变函数的this对象的指向的，他们有什么样的区别呢。 在说区别之前还是先总结一下三者的相似之处： 都是用来改变函数的this对象的指向的。 第一个参数都是this要指向的对象。 都可以利用后续参数传参。 那么他们的区别在哪里的，先看一个例子。 var xw = { name: \"小王\", gender: \"男\", age: 24, say: function () { alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age); } } var xh = { name: \"小红\", gender: \"女\", age: 18 } xw.say(); 那么如何用xw的 say 方法来显示xh的数据呢。 对于call可以这样： xw.say.call(xh); 对于apply可以这样： xw.say.apply(xh); 而对于bind来说需要这样： xw.say.bind(xh)(); 总之：bind 与 apply 、 call 最大的区别就是： bind 不会立即调用，其他两个会立即调用， apply 与 call 的区别是 apply 第二个是参数组，但是在确定的参数下，还是最好用 call ， call 的效果会更高，但是在函数的延展性上使用 apply 更好 二、手写方法 2.1 手写一个call方法 考虑两点 第一个参数为undefined或null的时候，那么会转变为window 改变了this执行，让新的对象可以执行该函数。 Function.prototype.myCall = function (context) { // 判断是否是undefined和null if (typeof context === 'undefined' || context === null) { context = window } context.fn = this let args = [...arguments].slice(1) let result = context.fn(...args) delete context.fn return result } 2.2 apply Function.prototype.myApply = function (context) { if (typeof context === 'undefined' || context === null) { context = window } context.fn = this let args = arguments[1] let result if (args) { result = context.fn(...args) } else { result = context.fn() } delete context.fn return result } 2.3 bind实现 这里需要注意下，因为 bind 转换后的函数可以作为构造函数使用，此时 this 应该指向构造出的实例，而 bind 函数绑定的第一个参数。 Function.prototype.myBind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } let _this = this let args = [...arguments].slice(1) return function F() { // 判断是否被当做构造函数使用 if (this instanceof F) { return _this.apply(this, args.concat([...arguments])) } return _this.apply(context, args.concat([...arguments])) } } Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 15:48:57 "},"gitbook/JavaScript-library/CrossDomain.html":{"url":"gitbook/JavaScript-library/CrossDomain.html","title":"跨域","keywords":"","body":"跨域 一、介绍 什么是跨域？ 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源 什么是同源策略？ 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 url 哪些地方不同算作跨域？协议、域名、端口，三个有两个不同就是不同的源，就是跨域 二、 限制 同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js对象无法获得 AJAX 请求不能发送 三、解决办法 跨域解决方案 通过jsonp跨域 iframe跨域 跨域资源共享（CORS） nginx代理跨域 nodejs中间件代理跨域 3.1 通过jsonp跨域 通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.domain2.com:8080/login?user=admin&callback=onBack'; document.head.appendChild(script); // 回调执行函数 function onBack(res) { alert(JSON.stringify(res)); } 3.2 跨域资源共享（CORS） 普通跨域请求： 只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。 需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：三、nginx反向代理中设置proxy_cookie_domain 和 四、NodeJs中间件代理中cookieDomainRewrite参数的设置。 目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 jQuery ajax $.ajax({ xhrFields: { withCredentials: true,// 前端设置是否带cookie }, crossDomain: true,// 会让请求头中包含跨域的额外信息，但不会含cookie... }); 3.3 nginx代理跨域 nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 location/{add_header Access-Control-Allow-Origin*;} nginx反向代理接口跨域 跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 nginx具体配置： server { listen 81; server_name www.domain1.com; location / { proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; } } 3.4 Nodejs中间件代理跨域 node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。 非vue框架的跨域（2次跨域） 利用node + express + http-proxy-middleware搭建一个proxy服务器。 //前端代码示例： var xhr = new XMLHttpRequest(); // 前端开关：浏览器是否读写cookie xhr.withCredentials = true; // 访问http-proxy-middleware代理服务器 xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true); xhr.send(); // 中间件服务器： var express = require('express'); var proxy = require('http-proxy-middleware'); var app = express(); app.use('/', proxy({ // 代理跨域目标接口 target: 'http://www.domain2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) { res.header('Access-Control-Allow-Origin', 'http://www.domain1.com'); res.header('Access-Control-Allow-Credentials', 'true'); }, // 修改响应信息中的cookie域名 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 })); app.listen(3000); console.log('Proxy server is listen at port 3000...'); Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 13:32:31 "},"gitbook/JavaScript-library/Traversing/init.html":{"url":"gitbook/JavaScript-library/Traversing/init.html","title":"二叉树实现","keywords":"","body":"二叉树基本操作 第n层的节点数最多为2n个节点 2.n层二叉树最多有20+...+2n=2n+1-1个节点 第一个非叶子节点：length/2 一个节点的孩子节点：2n、2n+1 基本结构 插入，遍历，深度 function Node(data, left, right) { this.data = data; this.left = left; this.right = right; } Node.prototype = { show: function () { console.log(this.data); } } function Tree() { this.root = null; } Tree.prototype = { insert: function (data) { var node = new Node(data, null, null); if (!this.root) { this.root = node; return; } var current = this.root; var parent = null; while (current) { parent = current; if (data 二分查找 二分查找的条件是必须是有序的线性表。 和线性表的中点值进行比较，如果小就继续在小的序列中查找，如此递归直到找到相同的值。 function binarySearch(data, arr, start, end) { if (start > end) { return -1; } var mid = Math.floor((end + start) / 2); if (data == arr[mid]) { return mid; } else if (data Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-24 11:14:26 "},"gitbook/JavaScript-library/Traversing/handy.html":{"url":"gitbook/JavaScript-library/Traversing/handy.html","title":"二叉树遍历","keywords":"","body":"二叉树遍历 一、 介绍： 所谓二叉树的遍历，是指按照一定的顺序对二叉树的每一个节点均访问一次，且只访问一次。 二、方式 按照访问根节点的访问位置不同通常把二叉树的遍历分为三种方式： 前序遍历、中序遍历、后序遍历 2.1 前序遍历 首先访问根节点，然后访问根节点的左子树，在访问根节点的右子树。 遍历结果：abdefgc function DLR(tree){ console.log(tree.value); if(tree.left){ DLR(tree.left); } if(tree.right){ DLR(tree.right); } } var inorderTraversal = function (root) { const result = []; const stack = []; let current = root; while (current || stack.length > 0) { while (current) { stack.push(current); result.push(current.val); current = current.left; } current = stack.pop(); current = current.right; } return result; }; 2.2 中序遍历 首先访问根节点的左子树，然后访问根节点，再访问根节点右子树 遍历结果: debgfac function LDR(tree){ if(tree.left){ LDR(tree.left); } console.log(tree.data); if(tree.right){ LDR(tree.right); } } var inorderTraversal = function (root) { const result = []; const stack = []; let current = root; while (current || stack.length > 0) { while (current) { stack.push(current); current = current.left; } current = stack.pop(); result.push(current.data); current = current.right; } return result; }; 2.3 后序遍历 首先访问根节点的左子树，然后访问根节点的右子树，最后访问根节点 遍历结果：edgfbca function LRD(tree){ if(tree.left){ LRD(tree.left); } if(tree.right){ LRD(tree.right); } console.log(tree.value); } // 取跟节点为目标节点，开始遍历 // 1.左孩子入栈 -> 直至左孩子为空的节点 // 2.栈顶节点的右节点为空或右节点被访问过 -> 节点出栈并访问他，将节点标记为已访问 // current.right == last 用来记录右面已经访问了，可以输出中间值了 // 3.栈顶节点的右节点不为空且未被访问，以右孩子为目标节点，再依次执行1、2、3 var inorderTraversal = function (root) { const result = []; const stack = []; let current = root; while (current || stack.length > 0) { while (current) { stack.push(current); result.push(current.val); current = current.left; } current = stack[stack.length - 1]; if (!current.right || current.right == last) { current = stack.pop(); result.push(current.data); last = current; current = null; // 继续弹栈 } else { current = current.right; } } return result; }; Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-24 11:15:32 "},"gitbook/JavaScript-library/Traversing/rebuild.html":{"url":"gitbook/JavaScript-library/Traversing/rebuild.html","title":"二叉树重建","keywords":"","body":"二叉树重建 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如输入前序遍历序列 {1,2,4,7,3,5,6,8} 和中序遍历序列 {4,7,2,1,5,3,8,6} ，则重建二叉树并返回。 思路 前序遍历：跟节点 + 左子树前序遍历 + 右子树前序遍历 中序遍历：左子树中序遍历 + 跟节点 + 右字数中序遍历 后序遍历：左子树后序遍历 + 右子树后序遍历 + 跟节点 具体实现 前序遍历找到根结点root 找到root在中序遍历的位置 -> 左子树的长度和右子树的长度 截取左子树的中序遍历、右子树的中序遍历 截取左子树的前序遍历、右子树的前序遍历 递归重建二叉树 function rebuild(pre, vin) { if (pre.length === 0) { return null; } if (pre.length === 1) { return new Tree(pre[0]); } const value = pre[0]; const index = vin.indexOf(value); const vinLeft = vin.slice(0, index); const vinRight = vin.slice(index + 1); const preLeft = pre.slice(1, index + 1); const preRight = pre.slice(index + 1); const node = new Tree(value); node.left = rebuild(preLeft, vinLeft); node.right = rebuild(preRight, vinRight); return node; } Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-24 11:21:30 "},"gitbook/JavaScript-library/Traversing/other.html":{"url":"gitbook/JavaScript-library/Traversing/other.html","title":"其他","keywords":"","body":"1. 判断是否是后续遍历 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路 后序遍历：分成三部分：最后一个节点为跟节点，第二部分为左子树的值比跟节点都小，第三部分为右子树的值比跟节点都大。 先检测左子树，左侧比跟节点小的值都判定为左子树。 除最后一个节点外和左子树外的其他值为右子树，右子树有一个比跟节点小，则返回false。 若存在，左、右子树，递归检测左、右子树是否复合规范。 代码 function VerifySquenceOfBST(sequence) { if (sequence && sequence.length > 0) { var root = sequence[sequence.length - 1] for (var i = 0; i root) { break; } } for (let j = i; j 0) { left = VerifySquenceOfBST(sequence.slice(0, i)); } var right = true; if (i 2. 获取最大深度 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 思路 深度优先遍历 + 分治 一棵二叉树的最大深度等于左子树深度和右子树最大深度的最大值 + 1 function TreeDepth(pRoot) { return !pRoot ? 0 : Math.max(TreeDepth(pRoot.left), TreeDepth(pRoot.right)) + 1 } Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-24 11:29:16 "},"gitbook/JavaScript-library/EventLoop.html":{"url":"gitbook/JavaScript-library/EventLoop.html","title":"Event Loop","keywords":"","body":"Event Loop 一、前言 Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。 为啥要弄懂Event Loop? 了解JavaScript的运行机制。 现在在前端领域各种技术层出不穷，掌握底层原理，可以让自己以不变，应万变 二、栈、队列 2.1 栈（Stack） 栈在计算机科学中是限定仅在表尾进行插入或删除操作的线性表。 栈是一种数据结构，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。 栈是只能在某一端插入和删除的特殊线性表。 2.2 队列（Queue） 在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out） 三、分类 在JavaScript中，任务被分为两种，一种宏任务（MacroTask）也叫Task，一种叫微任务（MicroTask）。 3.1 MacroTask（宏任务） script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。 3.2 MicroTask（微任务） Process.nextTick（Node独有）、Promise、Object.observe(废弃) 三、浏览器中Event Loop Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。 3.1 JS调用栈 JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。 3.2 同步任务和异步任务 Javascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。 事件循环的进程模型 选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务（MicroTask）的执行步骤。 将事件循环中的任务设置为已选择任务。 执行任务。 将事件循环中当前运行任务设置为null。 将已经运行完成的任务从任务队列中删除。 microtasks步骤：进入microtask检查点。 更新界面渲染。 返回第一步。 执行进入microtask检查点时，用户代理会执行以下步骤： 设置microtask检查点标志为true。 当事件循环microtask执行不为空时：选择一个最先进入的microtask队列的microtask，将事件循环的microtask设置为已选择的microtask，运行microtask，将已经执行完成的microtask为null，移出microtask中的microtask。 设置进入microtask检查点的标志为false。 执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去检查微任务(microTask)队列是否为空，如果为空的话，就执行Task（宏任务），否则就一次性执行完所有微任务。 每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。 四、example console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); Promise.resolve().then(function() { console.log('promise1'); }).then(function() { console.log('promise2'); }); console.log('script end'); 4.1 第一次执行： Tasks：run script、 setTimeout callback Microtasks：Promise then JS stack: script Log: script start、script end。 执行同步代码，将宏任务（Tasks）和微任务(Microtasks)划分到各自队列中。 4.2 第二次执行： Tasks：run script、 setTimeout callback Microtasks：Promise2 then JS stack: Promise2 callback Log: script start、script end、promise1、promise2 执行宏任务后，检测到微任务(Microtasks)队列中不为空，执行Promise1，执行完成Promise1后，调用Promise2.then，放入微任务(Microtasks)队列中，再执行Promise2.then。 4.3 第三次执行： Tasks：setTimeout callback Microtasks： JS stack: setTimeout callback Log: script start、script end、promise1、promise2、setTimeout 当微任务(Microtasks)队列中为空时，执行宏任务（Tasks），执行setTimeout callback，打印日志。 4.4 第四次执行： Tasks：setTimeout callback Microtasks： JS stack: Log: script start、script end、promise1、promise2、setTimeout 清空Tasks队列和JS stack。 以上执行帧动画可以查看Tasks, microtasks, queues and schedules 五、example2 console.log('script start') async function async1() { await async2() console.log('async1 end') } async function async2() { console.log('async2 end') } async1() setTimeout(function() { console.log('setTimeout') }, 0) new Promise(resolve => { console.log('Promise') resolve() }) .then(function() { console.log('promise1') }) .then(function() { console.log('promise2') }) console.log('script end') 这里需要先理解async/await。 async/await 在底层转换成了 promise 和 then 回调函数。 也就是说，这是 promise 的语法糖。 每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。 async/await 的实现，离不开 Promise。从字面意思来理解，async 是“异步”的简写，而 await 是 async wait 的简写可以认为是等待异步方法执行完成。 关于73以下版本和73版本的区别 在老版本版本以下，先执行promise1和promise2，再执行async1。 在73版本，先执行async1再执行promise1和promise2。 73版本 首先，打印script start，调用async1()时，返回一个Promise，所以打印出来async2 end。 每个 await，会新产生一个promise,但这个过程本身是异步的，所以该await后面不会立即调用。 继续执行同步代码，打印Promise和script end，将then函数放入微任务队列中等待执行。 同步执行完成之后，检查微任务队列是否为null，然后按照先入先出规则，依次执行。 再回到await的位置执行返回的 Promise 的 resolve 函数，这又会把 resolve 丢到微任务队列中，打印async1 end 然后先执行打印promise1,此时then的回调函数返回undefinde，此时又有then的链式调用，又放入微任务队列中，再次打印promise2。 当微任务队列为空时，执行宏任务,打印setTimeout。 复制文件 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 14:26:40 "},"gitbook/JavaScript-library/Currying.html":{"url":"gitbook/JavaScript-library/Currying.html","title":"柯里化","keywords":"","body":"一、通用版 function curry(fn) { var args = Array.prototype.slice.call(arguments, 1); return function () { var newArgs = args.concat(Array.prototype.slice.call(arguments)); return fn.apply(this, newArgs); } } 执行： function multiFn(a, b, c) { return a * b * c; } var multi = curry(multiFn); multi(2, 3, 4); 二、改进版 就题目而言，是需要执行三次函数调用，那么针对柯里化后的函数，如果传入的参数没有 3 个的话，就继续执行 curry 函数接收参数，如果参数达到 3 个，就执行柯里化了的函数。 function curry(fn, args) { var length = fn.length; var args = args || []; return function () { newArgs = args.concat(Array.prototype.slice.call(arguments)); if (newArgs.length 三、优化版 function multi() { var args = Array.prototype.slice.call(arguments); var fn = function () { var newArgs = args.concat(Array.prototype.slice.call(arguments)); return multi.apply(this, newArgs); } fn.toString = function () { return args.reduce(function (a, b) { return a * b; }) } return fn; } 最后这个其实是利用了toString()函数的返回值为String类型。返回当前对象的字符串形式。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-09 17:38:01 "},"gitbook/JavaScript-library/Security.html":{"url":"gitbook/JavaScript-library/Security.html","title":"web攻击","keywords":"","body":"web攻击 1. 定义 随着Web2.0、社交网络、微博等等一系列新型的互联网产品的诞生，基于Web环境的互联网应用越来越广泛，企业信息化的过程中各种应用都架设在Web平台上，Web业务的迅速发展也引起黑客们的强烈关注，接踵而至的就是Web安全威胁的凸显，黑客利用网站操作系统的漏洞和Web服务程序的SQL注入漏洞等得到Web服务器的控制权限，轻则篡改网页内容，重则窃取重要内部数据，更为严重的则是在网页中植入恶意代码，使得网站访问者受到侵害。这也使得越来越多的用户关注应用层的安全问题，对Web应用安全的关注度也逐渐升温。 2. 攻击手段以及防范 XSS攻击 CSRF 点击劫持 SQL注入 OS注入 DDoS攻击 2.1 XSS攻击(跨站脚本攻击) XSS（Cross Site Scripting）跨站脚本攻击，为了不与层叠样式表（CSS）混淆，故将跨站脚本攻击缩写为XSS。原理即在网页中嵌入恶意脚本(js或者html标签)，当用户打开网页时，恶意脚本便开始在用户浏览器上执行，以盗取客户端cookie、用户名、密码，发送恶意请求，甚至下载木马程式，危害可想而知。 XSS通常可以分为两大类（主要来源于前后端未对数据进行处理）： 反射型XSS(url直接注入)，主要做法是将脚本代码加入URL地址的请求参数里，请求参数进入程序后在页面直接输出，用户点击类似的恶意链接就可能受到攻击（出现把URl中参数渲染到页面中）。// 普通 http://localhost:3000/?from=china // alert尝试 http://localhost:3000/?from=alert(3) // 短域名伪造 https://dwz.cn/ 存储型XSS（存储在后端数据库里），主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等。攻击者在相关页面输入恶意的脚本数据后,应用程序从数据库中查询数据，在页面中显示出来，用户浏览此类页面时就可能受到攻击。这个流程简单可以描述为：恶意用户的Html输入Web程序->进入数据库->Web程序->用户浏览器（提交数据前后端都未做处理，直接存储到数据库中）。 危害： 获取页面数据 获取Cookies 劫持前端逻辑 发送请求 欺骗用户 防范： 前端对于url中数据使用时进行处理 如果是后端直接进行页面渲染(主要是用来设置header来控制)// 一般浏览器现在都防止xss攻击，但是现在谷歌已经放开 ctx.set('X-XSS-Protection', 0) // 禁止XSS过滤 // http://localhost:3000/?from=alert(3) 可以拦截 但伪装一下就不不行行了了（使用域名网站转换） // 只允许加载本站资源 Content-Security-Policy: default-src 'self' // 只允许加载 HTTPS 协议图⽚片 Content-Security-Policy: img-src https://* // 不不允许加载任何来源框架 Content-Security-Policy: child-src 'none' 转移字符-黑名单 用户的输入永远不不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行行转义(但是对于富文本来说是不合适的所有更推荐使用白名单) function escape(str) { str = str.replace(/&/g, '&amp;') str = str.replace(//g, '&gt;') str = str.replace(/\"/g, '&quto;') str = str.replace(/'/g, '&#39;') str = str.replace(/`/g, '&#96;') str = str.replace(/\\//g, '&#x2F;') return str } 转移字符-白名单 其实和黑名单一样逻辑差不多都是对字符的转义,只是白名单是有选择性的 // node中 const xss = require('xss') let html = xss('XSS Demoalert(\"xss\");') // -> XSS Demo&lt;script&gt;alert(\"xss\");&lt;/script&gt; console.log(html) 设置cookie httpOnly 这是预防XSS攻击窃取用户cookie最有效的防御手段。Web应 用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。 //node中 response.addHeader(\"Set-Cookie\", \"uid=112; Path=/; HttpOnly\") 2.2 CSRF CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，它利利用用户已登录的身份，在用户毫不不知情的情况下，以用户的名义完成非法操作。 用户登录受信站点A，生成本地cookie； 用户没有退出站点A，访问了恶意站点B。 站点A没做CSRF防御 document.write(` 添加评论: `) var iframe = document.createElement('iframe') iframe.name = 'csrf' iframe.style.display = 'none' document.body.appendChild(iframe) setTimeout(function() { document.querySelector('form').submit(); },1000) //指向iframe是为了做到无刷新提交 // 这样当A网站登录后，B网站模拟A网站发出请求 危害： 完成业务请求 盗取用户资金（转账，消费） 冒充用户发帖背锅 损害网站声誉 防范： 通过Referer识别- Https不不发送referer(不常用) Http头中有一个字段Referer，它记录了Http请求来源地址。但是注意不要把Rerferer用在身份验证或者其他非常重要的检查上，因为Rerferer非常容易在客户端被改变。（火狐的一个插件RefControl修改Referer引用） 验证码（加大犯罪成本） token CSRF攻击之所以成功，主要是攻击中伪造了用户请求，而用户请求的验证信息都在cookie中，攻击者就可以利用cookie伪造请求通过安全验证。因此抵御CSRF攻击的关键就是，在请求中放入攻击者不能伪造的信息，并且信息不在cookie中 鉴于此，开发人员可以在http请求中以参数的形式加一个token，此token在服务端生成，也在服务端校验，服务端的每次会话都可以用同一个token。如果验证token不一致，则认为至CSRF攻击，拒绝请求。 cookie值进行hash： 请求的时候再带上一个参数，把cookie进行hash处理，后端通过判断cookie和这个参数来判断是否是CSRF攻击 2.3 点击劫持 点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。 危害： 会冒充用户点赞等功能（不需要输入的一些操作） 防范： X-FRAME-OPTIONS X-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了了防御用 iframe 嵌套的点击劫持攻击。 该响应头有三个值可选，分别是 DENY，表示页面不允许通过 iframe 的方式展示 SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示 ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示 前端做处理if (self == top) { var style = document.getElementById('click-jack') document.body.removeChild(style) } else { top.location = self.location } //以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了了 2.4 SQL注入 攻击者成功的向服务器提交恶意的SQL查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。 // node环境中 // 填入特殊密码 1'or'1'='1 // 拼接后的SQL SELECT * FROM test.user WHERE username = 'laowang' AND password = '1'or'1'='1' 防范： 所有的查询语句建议使用数据库提供的参数化查询接口**，参数化的语句使用参数而不是将用户输入变量量嵌入到 SQL 语句中，即不要直接拼 SQL 语句。例如 Node.js 中的 mysqljs 库的 query方法中的 ? 占位参数。/ 错误写法 const sql = ` SELECT * FROM test.user WHERE username = '${ctx.request.body.username}' AND password = '${ctx.request.body.password}' ` console.log('sql', sql) res = await query(sql) // 正确的写法 const sql = ` SELECT * FROM test.user WHERE username = ? AND password = ? ` console.log('sql', sql, ) res = await query(sql,[ctx.request.body.username, ctx.request.body.password]) 后端代码检查输入的数据是否符合预期，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。 对进入数据库的特殊字符（'，\"，\\，，&，*，; 等）进行转义处理，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。 2.5 OS命令注入 OS命令注入和SQL注入差不多，只不过SQL注入是针对数据库的，而OS命令注入是针对操作系统的。OS命令注入攻击指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险。倘若调用Shell时存在疏漏，就可以执行插入的非法命令。 // 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repo const exec = require('mz/child_process').exec; let params = {/* 用户输入的参数 */}; exec(`git clone ${params.repo} /some/path`); //如果传入的参数是会怎样 https://github.com/xx/xx.git && rm -rf /* && 2.6 DDOS DDOS 里面的 DOS 是 denial of service（停止服务）的缩写，表示这种攻击的目的，就是使得服务中断。最前面的那个 D 是 distributed （分布式），表示攻击不是来自一个地方，而是来自四面八方，因此更难防。你关了前门，他从后门进来；你关了后门，他从窗口跳起来。DDOS 不是一种攻击，而是一大类攻击的总称. 攻击： SYN flood(三次握手中的一次不回应) 攻击者伪造大量无效IP，不断与目标主机建立TCP链接，导致服务器维护了一个非常大的链接等待列表，占用大量系统资源，直至新链接无法建立。 这种攻击是利用了TCP三次握手的异常处理机制，即第三次握手，服务端在没有收到客户端ACK报文时，服务端会进行多次SYN+ACK重试，然后维护一个等待列表，而系统会为即将建立的TCP连接分配一部分资源。资源耗尽，系统也就无法再建立TCP连接。 HTTP Flood 此攻击类似于同时在多个不同计算机上反复按Web浏览器器中的刷新 - 大量HTTP请求泛滥服务器，导致拒绝服务。 防范 备份网站 防范 DDOS 的第一步，就是你要有一个备份网站，或者最低限度有一个临时主页。生产服务器万一下线了，可以立刻切换到备份网站，不至于毫无办法。 HTTP 请求的拦截（靠谱的运营商） 专用硬件(价格高)>本机防火墙>web 服务器 带宽扩容+CDN 扩大容量，减少风险 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-09 17:53:48 "},"gitbook/JavaScript-library/Sudoku/number.html":{"url":"gitbook/JavaScript-library/Sudoku/number.html","title":"九宫格","keywords":"","body":" 数独游戏 完成 重置 重玩本局 11  21  31      41  51  61      71 81  91 12  22  32      42  52  62      72  82  92 13  23  33      43  53  63      73  83  93 14  24  34      44  54  64      74  84  94   15  25  35      45  55  65      75  85  95   16  26  36      46  56  66      76  86  96 17  27  37      47  57  67      77  87  97   18  28  38      48  58  68      78  88  98   19  29  39      49  59  69      79  89  99   var sd = new SD; sd.init(30); Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-28 19:10:59 "},"gitbook/HTTP-library/":{"url":"gitbook/HTTP-library/","title":"HTTP","keywords":"","body":"Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-09 19:50:35 "},"gitbook/HTTP-library/Code.html":{"url":"gitbook/HTTP-library/Code.html","title":"状态码","keywords":"","body":"HTTP常见状态码 2XX 成功 200 OK，表示从客户端发来的请求在服务器端被正确处理 204 No content，表示请求成功，但响应报文不含实体的主体部分 206 Partial Content，进行范围请求 3XX 重定向 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL 302 found，临时性重定向，表示资源临时被分配了新的 URL 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况 307 temporary redirect，临时重定向，和302含义相同 4XX 客户端错误 400 bad request，请求报文存在语法错误 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 403 forbidden，表示对请求资源的访问被服务器拒绝 404 not found，表示在服务器上没有找到请求的资源 5XX 服务器错误 500 internal sever error，表示服务器端在执行请求时发生了错误 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-09 19:54:48 "},"gitbook/HTTP-library/Cache.html":{"url":"gitbook/HTTP-library/Cache.html","title":"HTTP缓存","keywords":"","body":"HTTP缓存 一、介绍 Http 缓存机制作为 web 性能优化的重要手段，对于从事 Web 开发的同学们来说，应该是知识体系库中的一个基础环节，同时对于有志成为前端架构师的同学来说是必备的知识技能。 在介绍 HTTP 缓存之前，先简单介绍一下HTTP报文 HTTP 报文就是浏览器和服务器间通信时发送及响应的数据块。 浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文。 报文信息主要分为两部分 包含属性的首部(header)--------------------------附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中 包含数据的主体部分(body)-----------------------HTTP请求真正想要传输的部分 二、 缓存分类 HTTP 缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存）两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。 2.1 强制缓存 强制缓存（状态码还是200）命中强缓存时，浏览器并不会将请求发送给服务器。在 Chrome 的开发者工具中看到 http 的返回码是200，但是在 Size 列会显示为(from cache)。 对于强制缓存来说，响应 header 中会有两个字段来标明失效规则（Expires/Cache-Control） 使用 chrome 的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况 Expires Expires 的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。 不过 Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用 HTTP 1.1，所以它的作用基本忽略。 另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。 所以HTTP 1.1 的版本，使用 Cache-Control 替代。 Cache-Control Cache-Control 是最重要的规则。常见的取值有 private 、public 、no-cache 、max-age ，no-store，默认为 private 。 private: 客户端可以缓存 public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的） max-age=xxx: 缓存的内容将在 xxx 秒后失效 no-cache: 需要使用对比缓存来验证缓存数据（后面介绍） no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so...基本上和它说886） 2.2 对比缓存 对比缓存（状态码还是304）对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。 浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。 再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。 Last-Modified / If-Modified-Since Last-Modified： 浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间 If-Modified-Since： 再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。 服务器收到请求后发现有头 If-Modified-Since 则与被请求资源的最后修改时间进行比对。 若资源的最后修改时间大于 If-Modified-Since ，说明资源又被改动过，则响应整片资源内容，返回状态码200； 若资源的最后修改时间小于或等于 If-Modified-Since ，说明资源无新修改，则响应 HTTP 304，告知浏览器继续使用所保存的cache。 Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since ） ETag(resp)/If-None-Match（req） 与 Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag 可以保证每一个资源是唯一的，资源变化都会导致ETag变化*。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的 If-None-Match 值来判断是否命中缓存。 三、 总结 对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。 对于比较缓存，将缓存信息中的 Etag 和 Last-Modified 通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 15:42:14 "},"gitbook/HTTP-library/InternetProtocol.html":{"url":"gitbook/HTTP-library/InternetProtocol.html","title":"因特网协议","keywords":"","body":"五层因特网协议 因特网协议的缩写是IP，意思是网络之间互连的协议，也就是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。 通俗的讲：IP地址也可以称为互联网地址或Internet地址。是用来唯一标识互联网上计算机的逻辑地址. 因特网协议栈共有五层：应用层、传输层、网络层、链接层和物理层。不同于OSI七层模型这也是实际使用中使用的分层方式。 互联网的每一层，都定义了很多协议。这些协议的总称，就叫做\"互联网协议\"（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。 一、实体层 实体层也叫物理层，它就是把电脑连接起来的物理手段。它主要规定了网络的一些特性，作用是负责传送0和1的电信号。 二、链接层 两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。\"链接层\"的功能:它在\"实体层\"的上方，确定了0和1的分组方式。在两个相邻节点之间传送数据时，数据链路层将网络层接下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等） 2.1 以太网协议 早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做\"以太网\"（Ethernet）的协议，占据了主导地位。 以太网规定，一组电信号构成一个数据包，叫做\"帧\"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data） \"标头\"包含数据包的一些说明项，比如发送者、接受者、数据类型等等；\"数据\"则是数据包的具体内容。如果数据很长，就必须分割成多个帧进行发送。 2.2 MAC地址 以太网数据包的\"标头\"，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？ 以太网规定，连入网络的所有设备，都必须具有\"网卡\"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。有了MAC地址，就可以定位网卡和数据包的路径了。 2.3广播 定义地址只是第一步，后面还有更多的步骤。 首先，一块网卡怎么会知道另一块网卡的MAC地址？ 回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。 其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？ 回答是以太网采用了一种很\"原始\"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。 上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的\"标头\"，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做\"广播\"（broadcasting）。 有了数据包的定义、网卡的MAC地址、广播的发送方式，\"链接层\"就可以在多台计算机之间传送数据了。 三、网络层 网络层作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做\"网络地址\"，简称\"网址\"。 于是，\"网络层\"出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。 网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。 3.1IP协议 规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。 目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。 但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。 那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数\"子网掩码\"（subnet mask）。 所谓\"子网掩码\"，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。 是否子在同一子网 算法只要把ＩＰ和子网掩码的每位数AND就可以了。 　　AND方法：0和1＝0　0和0＝0　1和1＝1 　　如：And　192.168.0.1，255.255.255.0，先转换为二进制，然后AND每一位 　　ＩＰ　　　　　　11000000.10101000.00000000.00000001 　　子网掩码　　　　11111111.11111111.11111111.00000000 　　得出AND结果　　 11000000.10101000.00000000.00000000 　　转换为十进制192.168.0.0，这就是网络标识， 再将子网掩码反取，也就是： 00000000.00000000.00000000.11111111， 　　 与IP　AND　得出结果： 00000000.00000000.00000000.00000001， 　　 转换为10进制，即0.0.0.1， 　 　这0.0.0.1就是主机标识。 3.2 IP数据包 根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。 但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？ 回答是不需要，我们可以把IP数据包直接放进以太网数据包的\"数据\"部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。 具体来说，IP数据包也分为\"标头\"和\"数据\"两个部分。 \"标头\"部分主要包括版本、长度、IP地址等信息，\"数据\"部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样 3.3 ARP协议 因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。 所以，我们需要一种机制，能够从IP地址得到MAC地址。 这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的\"网关\"（gateway），让网关去处理。 第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个\"广播\"地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。 总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。 四、传输层 有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。 接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？ 也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做\"端口\"（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。 \"端口\"是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。 \"传输层\"的功能，就是建立\"端口到端口\"的通信。相比之下，\"网络层\"的功能是建立\"主机到主机\"的通信。只要确定主机和端口，我们就能实现程序之间的交流。 4.1 UDP协议 现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。 UDP数据包，也是由\"标头\"和\"数据\"两部分组成。 \"标头\"部分主要定义了发出端口和接收端口，\"数据\"部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的\"数据\"部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样： 4.2 TCP协议 UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。 为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。 因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。 TCP数据包和UDP数据包一样，都是内嵌在IP数据包的\"数据\"部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 五、应用层 应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。 这是最高的一层，直接面对用户。它的数据就放在TCP数据包的\"数据\"部分。因此，现在的以太网的数据包就变成下面这样。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-20 14:58:22 "},"gitbook/HTTP-library/Tcp.html":{"url":"gitbook/HTTP-library/Tcp.html","title":"TCP通信","keywords":"","body":"TCP 通信 一、 OSI 七层协议模型、TCP/IP 四层模型各层对应 二、HTTP 与 HTTPS 的区别 三 、TCP/IP 通信传输流 发送端在层与层之间传输数据时，每经过一层必定会加上一个该层的首部信息。反之，接收端在层与层之间传输数据时，每经过一层会把相关的首部信息去掉。 四、TCP 三次握手和四次挥手 TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 三次握手 第一次握手： 建立连接时，向服务器发出连接请求报文，客户端进程进入已发送状态状态,等待服务器确认； 第二次握手： 服务器收到请求后，如果同意连接，则发出确认报文，此时服务器进程进入了 同步收到状态； 第三次握手： 客户端收到服务器的确认报文后，要向服务器给出确认，此时，TCP 连接建立，客户端进入已建立连接状态。 完成三次握手，客户端与服务器开始传送数据。 建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由 TCP 的半关闭（half-close）造成的。 四次挥手 第一次挥手： 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部 FIN=1，其序列号为 seq = u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入 FIN-WAIT-1（终止等待1）状态。 第二次挥手： 服务器收到连接释放报文，发出确认报文，ACK = 1，ack = u + 1，并且带上自己的序列号 seq = v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。 TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 第三次挥手： 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN = 1，ack = u + 1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq = w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。 第四次挥手： 客户端收到服务器的连接释放报文后，必须发出确认，ACK = 1，ack = w + 1，而自己的序列号是 seq = u + 1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。 注意此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。 服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。 可以看到，服务器结束 TCP 连接的时间要比客户端早一些。 四次的原因 这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。 但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你未必会马上会关闭 SOCKET ,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的. 由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 五、DNS 域名解析 当你在浏览器的地址栏输入 https://jianshu.com 后会发生什么，大家在心中肯定是有一个大概的，这里我将 DNS 域名解析 这个步骤详细的讲一遍。在讲概念之前我先放上一张经典的图文供大家思考一分钟。 六、查找域名对应的 IP 地址的具体过程 浏览器搜索自己的 DNS 缓存（浏览器维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步； 搜索操作系统中的 DNS 缓存；如果没有命中，进入下一步； 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步； 操作系统将域名发送至 LDNS （本地区域名服务器），LDNS 查询自己的 DNS 缓存（一般命中率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求： LDNS向 Root Name Server（根域名服务器，如com、net、im 等的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 im 域的顶级域名服务器的地址； LDNS 向 im 域的顶级域名服务器发起请求，返回jianshu.com 域名服务器地址； LDNS 向 jianshu.com 域名服务器发起请求，得到jianshu.com 的 IP 地址； LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来。 七、DNS Prefetch 即 DNS 预获取，是前端优化的一部分。一般来说，在前端优化中与 DNS 有关的有两点： 减少 DNS 的请求次数 进行 DNS 预获取 典型的一次 DNS 解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能减少用户的等待时间，提升用户体验。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-20 15:17:33 "},"gitbook/Regular-library/":{"url":"gitbook/Regular-library/","title":"Regular","keywords":"","body":"正则 1. 概念 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 2. 正则目的 给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）； 可以通过正则表达式，从字符串中获取我们想要的特定部分。 3. 正则特点 灵活性、逻辑性和功能性非常的强； 可以迅速地用极简单的方式达到字符串的复杂控制。 对于刚接触的人来说，比较晦涩难懂。 4. 正则的组成 5. 参考资料 了解正则的运行情况可以使用正则工具 地址 正则视频可以查看慕课网 正则初识（一）规则 Linux--shell脚本之正则表达式 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-28 17:39:13 "},"gitbook/Regular-library/composition.html":{"url":"gitbook/Regular-library/composition.html","title":"正则组成","keywords":"","body":"正则的组成 1. 字符类 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，n 匹配字符 n。\\n 匹配一个换行符。序列 \\\\ 匹配 \\ 而 \\( 则匹配 (。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]。 \\W 匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_]。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， [abc] 可以匹配 plain 中的 a。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， [^abc] 可以匹配 \"plain\" 中的p、l、i、n。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，[a-z] 可以匹配 a 到 z 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，'a-z可以匹配任何不在a到z` 范围内的任意字符。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v] 。 \\S 匹配任何非空白字符。等价于 [^\\f\\ [^ \\f\\n\\r\\t\\v]。 2. 量词 量词：在正则中表现出现次数的 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 \"z\" 以及 \"zoo\"。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 、 \"does\" 中的 \"does\" 、 \"doxy\" 中的 \"do\" 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 {n,m} m 和 n 均为非负整数，其中n 3. 位置限定符 字符 描述 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\\n' 或 '\\r' 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\\n' 或 '\\r' 之前的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\\b' 可以匹配\"never\" 中的 'er'，但不能匹配 \"verb\" 中的 'er'。 \\B 匹配非单词边界。'er\\B' 能匹配 \"verb\" 中的 'er'，但不能匹配 \"never\" 中的 'er'。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 5. 正则修饰符 字符 描述 i 忽略大小写 m 表示可以进行多行匹配，一般和$,^配合使用 g 全局查询 s 将字符串视为单行，换行符作为普通字符 ``` // i 使用 var str=\"bAcd\"; console.log(str.match(/a/i)) //如果不适用i不会匹配，使用i，忽略大小写，会匹配上A // g 使用 var str=\"abAcd\"; console.log(str.match(/a/gi)) //如果不适用g只会匹配上{a}，使用g，全局查询会匹配上[a,A] // m 使用 var str=\"bd76dfsdfsdfsdfs\\r\\nb76dsfsdb8fsdf\"; console.log(str.match(/^b./gm)); //如果不适用m只会匹配上{bd}，使用m表明可以进行多行匹配，全局查询会匹配上[bd,b7] // s 使用 var str=\"sbcpr\\nydddpray\"; console.log(str.match(/pr.y/gs)); //如果不适用s只会匹配上{pray}，使用m表明可以进行多行匹配，全局查询会匹配上[pr\\ny,pray] ``` Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-28 17:40:44 "},"gitbook/Regular-library/methods.html":{"url":"gitbook/Regular-library/methods.html","title":"正则方法","keywords":"","body":"方法 正则的方法包括正则的方法、js使用正则的方法 1. 正则的方法 1.1 test方法 该方法用来测试某个字符串是否与正则匹配，匹配就返回true，否则返回false。该方法接受一个字符串作为参数 ``` var reg=/boy(s)?\\s+and\\s+girl(s)?/gi; console.log(reg.test('boy and girl')); ``` 1.2 exec方法 该方法属于一个比较复杂的方法，它接受一个字符串，返回的是一个数组，数组中第0个元素是匹配的子字符串，第二个元素是正则中的第一个子分组匹配的结果（如果有子分组，即正则中存在用圆括号括起来的分组），第三个是正则中第二个子分组匹配的结果（如果有第二个子分组）...以此类推，如果没有正则子分组，那么该数组长度仅仅为1，就是匹配到的那个子字符串。同时，返回的这个数组同时还是一个对象，它拥有两个属性，分别为index表示当前匹配到的子字符串所处的位置，input属性表示被匹配的原始字符串。最后，该方法中的正则对象如果不是全局匹配，即没有g修饰符，则每次调用只会从字符串开头处匹配第一个结果，且每次调用结果都是一样的。只有指定为全局匹配，才能够按照从左往右依次去匹配，每次调用匹配一个结果，正则对象的lastIndex属性前进到本次匹配的末尾位置，下回再调用的时候，会从lastIndex处开始匹配而不是从头匹配。 ``` var reg=/(\\w)l(\\w)/g; var str=\"hello world hello 123 hello programmer hello test\"; var arr=reg.exec(str); while(arr){ console.dir(arr); console.log(\"lastIndex:\"+reg.lastIndex); arr=reg.exec(str); } ``` 2. js使用正则的方法 2.1 search方法 该方法是string对象的一个方法，用来查找第一次匹配的子字符串的位置，如果找到就返回一个number类型的index值，否则返回-1,它返回的只是第一次匹配的位置。 ``` var str=\"hello world\"; console.log(str.search(/o/g)); ``` 2.2 replace方法 该方法用来将字符串中的某些子串替换为需要的内容，接受两个参数，第一个参数可以为正则或者子字符串，表示匹配需要被替换的内容，第二个参数为被替换的新的子字符串。如果声明为全局匹配则会替换所有结果，否则只替换第一个匹配到的结果。 ``` var str=\"hello world,hello test\"; console.log(str.replace(/hello/g,'hi')); ``` 7.3 split方法 该方法主要用来将一个字符串拆分成一个数组，它接受一个正则或者子字符（串）作为参数，返回一个数组，简单情况下，我们不需要使用正则，只有在字符串拆分规则不统一的情况下才需要使用正则，如下： ``` var str=\"how|old*are you\"; var arr=str.split(/\\||\\*|\\s+/); console.log(arr); ``` 7.4. match方法 该方法接受一个正则作为参数，用来匹配一个字符串，它的输出结果在不是全局匹配的情况下和exec方法的结果一致即一个数组并带有额外的属性，如果采用全局匹配，则不返回任何和其被匹配字符串相关的信息，只返回匹配的结果。 ``` var reg3=/(\\w)s(\\w)/g; var str4=\"ws1estqsa\"; console.dir(str4.match(reg3)); ``` Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-27 16:16:03 "},"gitbook/Regular-library/used.html":{"url":"gitbook/Regular-library/used.html","title":"常用正则","keywords":"","body":"常用正则： 查看正则运行情况 2 到 9 位中文昵称：^[\\u4e00-\\u9fa5]{2,9}$ 只能是字母、数字和下划线，长度不限制一到多：^\\w+$ 允许 小写字母 a-z、大写字母 A-Z、数字 0-9、下划线 、 连接符 -，且长度在 6-18 位数：`/^[a-zA-Z0-9-]{6,18}$/` 必须包含数字+小写字母+大写字母的密码，且长度在8-10位之间：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 验证 Email允许有一个字符符合 [A-Za-z0-9] 之后可以为 [A-Za-z0-9-+.] + @ + 允许有一个字符符合 [A-Za-z0-9] 之后可以为 [A-Za-z0-9-.] + . + 允许有一个字符符合 [A-Za-z0-9] 之后可以有 [A-Za-z0-9-.] 的邮箱：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 验证身份证 18 位身份证号，尾数是数字或者字母 X：^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$ 15 或者 18 位身份证号，尾数可以是数字及 X 或者 x：(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 验证手机号 以 1 开头，第二位数是 3/4/5/7/8 的 11 位手机号码：^1[3|4|5|7|8|9]\\d{9}$ 移动号码：^134[0-8]\\d{7}$|^(?:13[5-9]|147|15[0-27-9]|178|1703|1705|1706|18[2-478])\\d{7,8}$ 电信号码：^(?:133|153|1700|1701|1702|177|173|18[019])\\d{7,8}$ 联通号码：^(?:13[0-2]|145|15[56]|176|1704|1707|1708|1709|171|18[56])\\d{7,8}|$ Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-28 18:08:46 "},"gitbook/Node-library/":{"url":"gitbook/Node-library/","title":"Node","keywords":"","body":"NPM 介绍 npm是随同nodejs 一起安装的包管理工具，能解决nodejs代码部署上的很多问题，常见的使用场景有一下几种： 允许用户从npm服务器下载别人编写的第三方包到本地使用（下载包） 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用（下载命令行程序） 允许用户将自己编写的包或者命令行程序上传到npm服务上供别人使用（上传） 命令 npm -v 查看当前版本（也可以测试是否安装成功） npm init -y y 的含义：yes的意思，在init的时候省去了敲回车的步骤，生成的默认的package.json npm i i是install 的缩写，下载packjson中需要的所有包 npm install（i） xxx@版本号 安装xxx 包，当有@版本号 默认下载固定版本 npm install xxx -g 全局安装 xxx包 npm install -S 下载生产依赖包 -S就是--save的简写 会存放在 package.json 的 devDependencies（里面的插件只用于开发环境，不用于生产环境） npm install -D 下载开发依赖包 -D就是--save-dev 会存放在 package.json 的 dependencies （需要发布到生产环境的） npm view xxx vesion 查看xxx包的版本号 npm uninstall xxx 或者 npm remove xxx 卸载 xxx 包 npm update xxx 更新xxx 包 npm info xxx 查看xxx 包的 详情 npm list 查看项目安装了那些包 npm root -g 查看全局安装包的存放位置 npm ls xxx 查看当前安装包的版本信息和安装目录 npm run xxx 运行packjson 中的script 的命令 npm help 查看帮助命令 npm link 执行 npm link 时候会将当前的文件软链接到node_modiles 上 在bin中配置 #!/usr/bin/env node 再在 packjson中bin 写上命令 指向当前文件 ，node为当前执行的环境 npm i nrm -g 全局下载 nrm , nrm ls 查看已安装镜像源 npm test测试那个速度快 npm use xxx 使用那个镜像 更多查看 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-19 14:53:43 "},"gitbook/Node-library/fs.html":{"url":"gitbook/Node-library/fs.html","title":"fs组件","keywords":"","body":"fs模块 介绍： Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。最好使用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞(重点)。对于流量较大的服务器，最好还是采用异步操作，同步操作时，只有前一个操作结束，才会开始后一个操作，如果某个操作特别耗时（常常发生在读写数据时），会导致整个程序停顿. 常用方法 操作 异步方法 同步方法 打开文件 fs.open(path, flags[, mode], callback) fs.openSync(path, flags[, mode]) 文件信息 fs.stat(path[, options], callback) fs.statSync(path[, options]) 新建文件 fs.appendFile(path, data[, options], callback) fs.appendFileSync(path, data[, options]) 写入文件 fs.writeFile(file, data[, options], callback) fs.writeFileSync(file, data[, options]) 读取文件 fs.read() 读取文件 fs.readFile(path[, options], callback) fs.readFileSync(path[, options]) 重命名文件 fs.rename(oldPath, newPath, callback) fs.renameSync(oldPath, newPath) 关闭文件 fs.close(fd, callback) fs.closeSync(fd) 截取文件 fs.ftruncate(fd[, len], callback) fs.ftruncateSync(fd[, len]) 删除文件 fs.unlink(path, callback) fs.unlinkSync(path) 文件存在 fs.stat() / fs.access() fs.existsSync(path) 监听文件 fs.watchFile(filename[, options], listener) 停止监听 fs.unwatchFile(filename[, listener]) 打开大文件 fs.createReadStream(path[, options]) 写入大文件 fs.createWriteStream(path[, options]) 创建目录 fs.mkdir(path[, options], callback) fs.mkdirSync(path[, options]) 读取目录 fs.readdir(path[, options], callback) fs.readdirSync(path[, options]) 删除目录 fs.rmdir(path, callback) fs.rmdirSync(path) Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-12 10:20:30 "},"gitbook/Node-library/koa.html":{"url":"gitbook/Node-library/koa.html","title":"koa","keywords":"","body":"koa 一、介绍 Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。 二、特点 koa 只是提供一个简单的架子，几乎所有的功能都由第三方中间件完成 轻量，无捆绑 中间件架构 优雅的API设计（把原生的res.end,res.writeHead 等命令进行处理，更加清晰） 增强的错误处理 （async的语法出现错误可以传递到顶层） 三、实现 3.1 使用 const koa=require('koa); const app=new koa(); app.use(ctx=>{ ctx.body='Hello Koa!' }) app.listen('30001) 3.2 koa实现逻辑 koa 实现整体还是使用的http 发送请求,进行服务的启停 在 koa源码的 application文件中，我们可以看到执行listen 方法的时候，其实是在创建一个http服务 // 启动服务 listen(...args) { debug('listen'); const server = http.createServer(this.callback()); return server.listen(...args); } 对 服务请求返回的res，req 进行处理，通过 get，set 进行代理，代理到 context上 在创建http 服务时候执行 this.callback(); 在这个方法中外卖可以看到 返回一个 handleRequest 方法，在这里将对req,res进行 处理， 新建一个上下文对象context，在context 中 使用 delegates 插件，把当前 请求在context中的attr 代理到this.request或者this.responese; 在 request.js 和 responese.js 文件中，通过 set 和get 方法 把 当前的属性代理到 this.req[attr]或者 this.res[attr]; 这样就可以实现属性的代理 callback() { const fn = compose(this.middleware); if (!this.listenerCount('error')) this.on('error', this.onerror); const handleRequest = (req, res) => { // 返回一个 context 对象，对req，res 中的属性进行代理 const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); }; return handleRequest; } // 处理返回一个context 对象 createContext(req, res) { const context = Object.create(this.context);// Object.create 可以继承set，get方法；结构性赋值和JSON.stringify和不能， const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.state = {}; return context; } // 在context 中 delegate(proto, 'response') // 使用delegates 吧 response中的属性代理到context 上 .method('attachment')// 代理的是方法 .access('status') //可读可写 .getter('writable'); //可读 // 在request 中 { get header() { return this.req.headers; }, } 使用compose 实现 中间件架构 compose 实现是对使用use 传递进来的function 进行处理，如果不是function 会报错 主要实现代码 function compose (middleware) { return function (context, next) { // last called middleware # let index = -1 // 刚进来先执行第一个函数 return dispatch(0) function dispatch (i) { if (i 四、插件 4.1 koa-router 路由 const Koa = require('koa'); // 直接调用的方式 const router = require('koa-router')(); // 或 单独创建router的实例 const Router = require('koa-router'); const router = new Router(); router.get('/', async ctx => { ctx.body = 'Hello Router'; }) // 启动路由 app.use(router.routes()).use(router.allowedMethods()) // 以上为官方推荐方式，allowedMethods用在routes之后，作用是根据ctx.status设置response header. app.listen(3000, err => { if (err) throw err; console.log('runing...'); }); 4.2 koa-bodyparser post 提交数据中间件 const bodyParser = require('koa-bodyparser'); app.use(bodyParser()); 4.3 koa-static 静态目录 app.use(require('koa-static')(path.join(__dirname, 'static'))); 4.4 koa-session session管理中间件 const Koa = require('koa'); const session = require('koa-session'); const app = new Koa(); app.keys = ['some secret hurr']; const CONFIG = { key: 'koa:sess', // 返给浏览器 cookie 的key 默认是 'kao:sess' maxAge: 86400000, // cookie的过期时间 maxAge in ms (default is 1 days) autoCommit: true, // (boolean) 自动给客户端下发cookie 并设置session overwrite: true, // 是否可以覆盖之前同名的cookie (默认default true) httpOnly: true, // cookie是否只有服务器端可以访问 httpOnly or not (default true) signed: true, // 签名默认true rolling: false, // 在每次响应时强制设置session标识符cookie，到期时被重置设置过期倒计时。（默认为false） renew: false, // 当session快过期时更新session，这样就可以始终保持用户登录 默认是false }; 4.5 koa2-cors 跨域处理 const cors = require('koa2-cors') app.use(cors()) 4.6 nodemailer 发邮件 const nodemailer = require(\"nodemailer\") async function main() { let transporter = nodemailer.createTransport({ host: \"smtp.qq.com\", port: 465, secure: true, // true for 465, false for other ports auth: { user: 'test@qq.com', pass: 'akphfubplzqdbdfh' } }) let info = await transporter.sendMail({ from: 'test@qq.com', // sender address to: \"bar@qq.com\", // 接收地址 多个邮箱使用 ','分割 subject: \"Hello 老胖\", // 邮件主题 text: \"胖子蹲啊胖子蹲胖子蹲完瘦子蹲\", // plain text body // html: \"嗯好\" // html body }) console.log(\"Message sent: %s\", info.messageId) console.log(\"Preview URL: %s\", nodemailer.getTestMessageUrl(info)) } 创建transporter配置信息 在node_modules>nodemailer>lib>well_known>services.json中查看对应的配置信息。配置发件邮箱相应的host、port及secure。 获取发件箱密码（类似于授权，获取key），以qq邮箱为例 qq邮箱>设置>账户>POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务，点击开启获取pass 配置user和pass user即发件地址 pass就是刚才授权获取的密码 sendMail配置信息 from 发件地址 to 收件地址 如果多个收件地址，用 ,分割即可 subject 邮件主题 text 文件内容 html html内容 4.7 错误处理 app.use(async (ctx, next)=> { await next(); if(ctx.status === 404){ ctx.body=\"404页面\" } }); Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-19 17:47:20 "},"gitbook/Mysql-library/":{"url":"gitbook/Mysql-library/","title":"Mysql","keywords":"","body":"CSS Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/Other-library/":{"url":"gitbook/Other-library/","title":"其他资料库","keywords":"","body":"CSS Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/Other-library/webpack.html":{"url":"gitbook/Other-library/webpack.html","title":"webpack 初始","keywords":"","body":"webpack 初始 1. 简介 webpack（模块打包工具）：webpack是一个打包模块化的Javascript的工具，它会 从入口模块出发，识别出源码中的模块化导入语句，递归的找出入口文件的所有依赖，将入口和其他所有的依赖打包到一个单独的文件. 2. 安装 2.1 全局安装 会造成多个项目只能使用同一个webpack版本 //在webpack 4.0版本需要安装两个 npm install webpack webpack-cli -g //检查版本 webpack -v // 卸载 npm uninstall webpack webpack-cli -g 2.2 局部安装 支持多个项目使用不同webpack版本 npm install webpack webpack-cli -D //局部安装 webpack 命令找不到 如何使用 方法一： ./node_modules/.bin/webpack node_modules/.bin 下 的文件都是可执行文件，都是原文件的软连接（符号链接） .bin 下面的文件都是npm 生成的 #!/usr/bin/env node #!：一般放在第一行，告诉使用者使用什么程序执行下面代码（软链接和符号链接叫法都和这个有关系） /usr/bin/env ：node 的位置 node：使用node执行 方法二：npx webpack npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装。 方法三： 配置package.json中的script \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"dev\": \"webapck\" }, 执行 npm run dev npm run 会创建一个shell脚本，这个脚本把当前项目的node_modules/.bin的绝对路径放在了系统的环境变量中 env：查看环境变量 rm -rf 与 rimraf 一样都是删除文件 scripts 中 有两种脚本钩子pre（前置钩子）,post（后置钩子），在dev前加上pre成predev，当执行dev的时候，回先执行predev，postdev为执行完dev后执行的命令 package.json 中的bin 作用 当文件被引入进去的时候,npm将软链接这个文件到prefix/bin里面,以便于全局引入,或在./node_modules/.bin/目录里； bin中的key值是引入时候的名称 3. 配置 webpack 4.x 默认只支持 js和json格式 默认配置 webpack.config.js const path=require('path'); module.exports={ //构建入口 entry:'./src/index.js', output:{ // path 为绝对路径 ，输出的目录 path:path.resolve(__dirname,'./dist'), filename:\"[name].js\",//输出的名称 }, mode:\"development\" } 3.1 入口 entry 指定webpack打包入口文件:Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入 适合一个单页面（spa），输入为字符串或者数组 entry: string|Array entry: './path/to/my/entry/file.js' | ['./path/to/my/entry/file.js'] 适合一个多页面应用（mpa），输入为对象 entry: {[entryChunkName: string]: string|Array} 上面的entry相当于 entry:{ main: './path/to/my/entry/file.js' , } 对象的key值为output输出适合的 name（默认为main）, 3.2 出口 output 打包转换后的文件输出到磁盘位置 output:{ // path 为绝对路径 ，输出的目录 path:path.resolve(__dirname,'./dist'), filename:\"[name]-[hash:6].js\", //输出的名称 name为多页面的key或者默认的main, //hash为此次构建的hash值，用于与缓存，后面的：6可以设置也可以不设置，设置数值为截取个数（长度） }, 3.3 mode Mode用来指定当前的构建环境（‘none' | 'production' | 'development'） 选项 描述 优点 development 会将 process.env.NODE_ENV 的值设为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。 开启有利于热更新处理，识别模块变化 production 会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin 开启压缩，处理副作用 none 退出任何默认优化选项 更灵活 3.4 module loader，模块解析，模块转换器器，用于把模块原内容按需转换成新内容，webpack默认只知道如何处理js和JSON模块，?那么其他模块如何处理呢，这就用到了不同的loader,但是一个loader只处理一件事 loader在一个test中 执行有顺序，从右像左，从下到上 module:{ rules:[ { test:/.css$/,//处理css use:[ { loader:'style-loader' //把css加入到html中 options:{ injectType: \"singletonStyleTag\" //将所有的style标签合并成一个 } }, }, 'css-loader' //处理css ], // use:['style-loader','css-loader'] }, { test:/.(png|jpe?g|gif)$/,//处理图片 use:{ // loader:'file-loader', //file-loader 只是移动文件，还有一个 loader:'url-loader',//url-loader 内部使用file-loader。可以处理所有的file-loader干的事，但是遇到jpg格式的模块，会把该图片转化成base64格式的字符串。 // 打包到js里，适合小体积的图片，大图片不合适 // 额外配置，比如名称。hash等 options:{ name:'[name]_[hash:6].[ext]',//输出name //name为本身文件的name,ext代表后缀 outputPath:'images/' //输出到的目录 } }, }, { test:/.(woff2?|ttf|svg|eot)$/,//处理字体 use:{ loader:'file-loader', //file-loader 只是移动文件，还有一个 options:{ name:'[name]_[hash:6].[ext]',//输出name //name为本身文件的name,ext代表后缀 outputPath:'font/' //输出到的目录 } }, } ] } css自动添加前缀 // npm i postcss-loader autoprefixer -D { test: /.css$/,//处理css use: [ { loader: 'style-loader', //把css加入到html中 options: { injectType: \"singletonStyleTag\" //将所有的style标签合并成一个 } }, 'css-loader', //处理css { loader: \"postcss-loader\", options: { // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: [ autoprefixer({ browsers: [ '>1%', 'last 4 versions', 'Firefox ESR', 'not ie 3.5 plugin 作用于webpack打包整个周期，webpack的打包过程是（有生命周期概念）钩子 扩展插件，在 Webpack 构建过程中的特定时机注入扩展逻辑来改变构建结果或想要做的事 3.5.1 HtmlWebpackPlugin htmlwebpackplugin会在打包结束后，自动生成一个html文件，并把打包生成的js模板加入到该html中 npm install --save-dev html-webpack-plugin new HtmlWebpackPlugin({ title:'hello world', template:'./index.html' }), 配置： 名称 作用 eg title 生成html页面中的header 需要设置html中title为（固定格式） filename 输出的html文件名 默认是index.html,也可以直接配置带有子目录的 '/public/index.html' template 模板html文件路径 ./index.html 绝对路径相对路径都支持 inject true或body或false或head 默认true，前两者添加js到body底部，后两张添加js到head favicon ico的路径，会自动输出到生成的目录中 './favicon.ico' 3.5.2 clean-webpack-plugin 在打包的时候清除生成的无效文件 npm install --save-dev clean-webpack-plugin const {CleanWebpackPlugin}=require('clean-webpack-plugin'); new CleanWebpackPlugin(), 3.5.2 clean-webpack-plugin 抽离css并且把css添加到html上 npm install --save-dev mini-css-extract-plugin const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); 需要再css-loader前加一个loder { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, \"css-loader\"] } new MiniCssExtractPlugin({ filename: \"[name][chunkhash:8].css\" }) 3.6 devtool 源代码与打包后的代码的映射关系，通过sourceMap定位到源代码 devtool的介绍：https://webpack.js.org/configuration/devtool#devtool eval:速度最快,使用eval包裹模块代码, source-map： 产生 .map 文件 cheap:较快，显示行数，不包含列信息 Module：第三方模块，包含loader的sourcemap（比如jsx to js ，babel的sourcemap） inline： 将 .map 作为DataURI嵌入，不单独生成 .map 文件 开发环境推荐开启 devtool:\"cheap-module-eval-source-map\" 3.7 WebpackDevServer 启动服务，提升开发效率 安装npm install webpack-dev-server -D 配置修改下package.json\"scripts\": { \"server\": \"webpack-dev-server\" }, 在webpack.config.js配置devServer: { contentBase: \"./dist\",//生成目录 open: true, // 是否打开浏览器 port: 8081, //端口 proxy:{ '/api':{ //以api开头的，不支持正则 target:\"http://localhost:3004\",// 目标机器 pathRewrite: {\"^/api\" : \"\"}//重写url 匹配可以使用正则 } } }, 在启动的时候其实不生成文件，把文件都储存在物流内存中，提升开发效率 3.8 hot-module-replacement HMR:热模块替换，不支持抽离出的css变化 npm i hot-module-replacement -D devServer: { contentBase: \"./dist\", open: true, hot:true,//启用 webpack 的模块热替换特性 hotOnly:true,//即便便HMR不生效，浏览器器也不自动刷新，就开启hotOnly }, plugins: [ new webpack.HotModuleReplacementPlugin() ] 如果非框架书写的 if (module.hot) { // 当模块b发生变化的时候，进行删除元素并重新执行 module.hot.accept(\"./b\", function() { document.body.removeChild(document.getElementById(\"number\")); number(); }); } // 框架书写的看框架使用的插件 [框架布局刷新](https://www.webpackjs.com/guides/hot-module-replacement/) [文档](https://www.webpackjs.com/api/hot-module-replacement/) 4.babel 中文网站 babel是JavaScript编译器器，能将ES6代码转换成ES5代码，让我们开发过程中放心使用JS新特性而不用担心兼容性问题。并且还可以通过插件机制根据需求灵活的扩展。 Babel在执行行编译的过程中，会从项目根目录下的 .babelrc JSON文件中读取配置。没有该文件会从loader的options地方读取配置。 npm i babel-loader @babel/core @babel/preset-env -D 1.babel-loader是webpack 与 babel的通信桥梁，不会做把es6转成es5的工作，这部分工作需要用到@babel/preset-env来做 2.@babel/preset-env里包含了了es6，7，8转es5的转换规则 env是babel7之后推行的预设插件 { test: /\\.js$/, exclude: /node_modules/, use: { loader: \"babel-loader\", options: { presets: [\"@babel/preset-env\"] } } } 通过上面的几步 还不够，默认的Babel只支持let等一些基础的特性转换，Promise等一些还没有转换过来，这时候需要借助@babel/polyfill，把es的新特性都装进来，来弥补低版本浏览器器中缺失的特性 @babel/polyfill 以全局变量的方式注入进来的。windows.Promise它会造成全局对象的污染 npm install --save @babel/polyfill 按需加载，减少冗余 { test: /\\.js$/, exclude: /node_modules/, use: { loader: \"babel-loader\", options: { presets: [ [ \"@babel/preset-env\", { targets: { edge: \"17\", firefox: \"60\", chrome: \"67\", safari: \"11.1\" }, corejs: 2,//新版本需要指定核心库版本 useBuiltIns: \"usage\"//按需注入 } ] ] } } } useBuiltIns 选项是 babel 7 的新功能，这个选项告诉 babel 如何配置 @babel/polyfill 。 它有三个参数可以使用： ①entry: 需要在 webpack 的入口文件里 import \"@babel/polyfill\" 一次。 babel 会根据你的使用情况导入垫片，没有使用的功能不会被导入相应的垫片。 ②usage: 不需要 import ，全自动检测，但是要安装 @babel/polyfill 。（试验阶段） ③false: 如果你 import \"@babel/polyfill\" ，它不不会排除掉没有使用的垫片，程序体积会庞大。(不不推荐) 请注意： usage 的行行为类似 babel-transform-runtime，不会造成全局污染，因此不会对类似Array.prototype.includes() 进行 polyfill。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-17 08:26:38 "},"gitbook/Other-library/Markdown_Website/":{"url":"gitbook/Other-library/Markdown_Website/","title":"Markdown_Website","keywords":"","body":"CSS Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/Other-library/Markdown_Website/Markdown/":{"url":"gitbook/Other-library/Markdown_Website/Markdown/","title":"Markdown","keywords":"","body":"Markdown 学习 目录 一 Markdown介绍 1.1 什么是Markdown  1.2 Markdown是谁创造的？  1.3 为什么要使用Markdown 二 Markdown 语法  2.1 标题  2.2 无序列表  2.3 有序列表  2.4 区块引用  2.5 分割线  2.6 链接  2.7 图片  2.8 代码框  2.9 表格  2.10 强调  2.11 转义  2.12 删除线  2.13 缩略标签 三 结语 一 Markdown介绍 1.1 什么是Markdown？ Markdown 是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。目前 github、Stackoverflow 等网站均支持这种格式。 Markdown 文件的后缀为 .md。 1.2 Markdown是谁创造的？ 它是由 Aaron Swartz 和 John Gruber 共同设计， Aaron Swartz 就是那位（2013年1月11日）自杀，有着开挂一般人生经历的程序员。 维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。 1.3 为什么要使用Markdown? 它是易读（看起来舒服&#x1F60C;）、易写（语法简单）、易更改（纯文本）。处处体现着极简主义的影子。 兼容HTML,可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown. 更方便清晰的组织你的电子邮件。（Markdown-here,Airmail）。 摆脱Word,txt！！！ 二 Markdown 语法 2.1 标题 用法介绍：标题可以像 HTML 一样使用一级至六级标题，使用 # 即可，一级标题的使用方法为：# 一级标题，几级标题就使用几个 #。 写法 #### 四级标题 ##### 五级标题 ###### 六级标题 演示： 四级标题 五级标题 六级标题 2.2 无序列表 用法介绍：无序列表可以使用 * + - 这三种格式，这里推荐使用*：* 列表1 写法 * 列表1 + 列表2 - 列表3 演示： 列表1 列表2 列表3 2.3 有序列表 用法介绍：有序列表使用数字1. **即可，如果开始数字是3，那这个列表就从3. \\**开始，第二条是4. *** 写法 1. 列表1 2. 列表2 3. 列表3 演示： 列表1 列表2 列表3 2.4 区块引用 用法介绍：区块引用使用 > 这个符号，空格后放文本即可：> 一级区块 写法 > 注意：区块引用的左边，有个竖线！ >> 注意：引用还可以嵌套使用，这是二级的引用，二级以上相信你也懂了 >>> 注意：这是三级嵌套，相信你知道怎么用了 演示： 注意：区块引用的左边，有个竖线！ 注意：引用还可以嵌套使用，这是二级的引用，二级以上相信你也懂了 注意：这是三级嵌套，相信你知道怎么用了 2.5 分割线 用法介绍：分割线使用三个及以上的 * 或者 - 或者 _ 都可，这里使用三个 *：*** 写法 *** --- ___ 演示： 2.6 链接 介绍：链接分为行内式和参数式这两种方法 2.6.1 行内式 写法 [webmryang 的网站](https://webmryang.github.io/) 演示： webmryang 的网站 2.6.2 参数式 写法 ``` [site]:https://webmryang.github.io \"网站\" [网站]:https://webmryang.github.io \"网站\" 这里是 [site]，这里是 [网站] ``` 演示： 这里是 site，这里是 网站 2.7 图片 用法介绍： 如果是本地图片，则支持绝对路径和相对路径 如果是网络图片，则可以使用 http://** 来引入 如果是 base64，怎么使用参考 markdown 引用 base64 写法 ![图片](https://qq.yh31.com/tp/zjbq/201901182223553205.gif) 演示： 2.8 代码框 介绍：代码框分为单行用和多行用这两种方法： 2.8.1 单行用 写法 `你好使用者，要看看` 演示： 你好使用者，要看看 2.8.2 多行用 写法 ``` 你好使用者，要看看 你好使用者，要看看 ``` 演示： 你好使用者，要看看 你好使用者，要看看 2.9 表格 介绍：表格有三种表示方法： 2.9.1 第一类表格 写法 | name | age | sex | | :---: | :--- | ---: | | webmryang | 23 | 男 | | 小杨 | 23 | 男 | 演示： name age sex webmryang 23 男 小杨 23 男 2.9.2 第二类表格 写法 | name | age | sex | | --- | --- | --- | | webmryang | 23 | 男 | | 小杨 | 23 | 男 | 演示： name age sex webmryang 23 男 小杨 23 男 2.9.3 第三类表格 写法 学号 | 姓名 | 分数 - | - | - 小明 | 男 | 75 小红 | 女 | 79 小陆 | 男 | 92 演示： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 2.10 强调 2.10.1 字体倾斜 写法 *字体倾斜* _字体倾斜_ 演示： 字体倾斜 字体倾斜 2.10.2 字体加粗 写法 **字体加粗** __字体加粗__ 演示： 字体加粗 字体加粗 2.11 转义 用法介绍：通过使用\\加上特殊字符，达到转义效果。 写法 * \\\\ * \\` * \\~ * \\* * \\_ * \\- * \\+ * \\. * \\! * …… 演示： \\ ` ~ * _ - + . ! …… 2.12 删除线 用法介绍：请删除我吧。 写法 ~~请删除我吧！~~ 演示： 请删除我吧！ 2.13 缩略标签 用法介绍缩略标签属于 HTML 中的内容，但是巧妙用在 Markdown 也是可行的。 写法 基础知识 被缩略 你还需要知道其他的吗？ 演示： 基础知识 被缩略 你还需要知道其他的吗？ 三 结语 至此，Markdown 语法介绍完毕，有兴趣的小伙伴继续去了解更深层次的 Markdown 语法吧！ Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:02:56 "},"gitbook/Other-library/Markdown_Website/GitBook/":{"url":"gitbook/Other-library/Markdown_Website/GitBook/","title":"GitBook 建站","keywords":"","body":"gitbook 1.1 gitbook介绍 GitBook 是一个基于 Node.js 的命令行工具，支持 Markdown 和 AsciiDoc 两种语法格式，可以输出 HTML、PDF、eBook 等格式的电子书。所以我更喜欢把 GitBook 定义为文档格式转换工具。 市面上我们可以找到很多 Markdown 编辑器，比如 Typora、MacDown、Bear、MarkdownPad、MarkdownX、JetBrains’s IDE（需要安装插件）、Atom、简书、CSDN 以及 GitBook 自家的 GitBook Editor 等等。 但 GitBook 又与 Markdown 和 Git 息息相关，因为只有将它们结合起来使用，才能将它们的威力发挥到极致！因此，通常我们会选择合适的 Markdown 编辑工具以获得飞一般的写作体验；使用 GitBook 管理文档，预览、制作电子书；同时通过 Git 管理书籍内容的变更，并将其托管到云端（比如 GitHub、GitLab、码云，或者是自己搭建的 Git 服务器），实现多人协作。 1.2 gitbook优点 简单来说，GitBook + Markdown + Git 带来的好处有： 语法简单 兼容性强 导出方便 专注内容 团队协作 1.3 结论 当然，GitBook 不是万能的，当我们需要复杂排版时，依然需要依托于 Word 等工具。但不用担心，因为我们可以把 Markdown 格式的文档导出为 Word 格式，再进一步加工。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-28 19:42:48 "},"gitbook/Other-library/Markdown_Website/GitBook/init.html":{"url":"gitbook/Other-library/Markdown_Website/GitBook/init.html","title":"环境搭建","keywords":"","body":"GitBook 初始化 gitbook是基于 node.js的命令工具，,首先需要安装并配置好node.js 环境,然后才能安装gitbook 相关工具. 1. gitbook 环境预检查 1.1 git 环境 git 是免费开源的分布式版本控制系统,主要用于电子书的更新管理和团队协作,如果不需要将电子书托管到github 网站上,则可以不安装 git . 如果打印出 git 版本信息,则表示本机已安装 git 环境,跳过此步骤. $ git --version git 安装配置教程请参考初识 git 1.2 node.js 环境 node.js 是 js 在服务端运行的环境基础,从而使得 js 从浏览器端延伸到服务端领域,而 gitbook 则是运行在 node.js 基础之上的命令行工具,因此必须先安装好 node.js 开发环境. 如果打印出 node.js 版本信息,则表示本机已安装 node.js 环境,跳过此步骤. $ node -v node.js 安装配置教程请参考 node 2. gitbook 安装 2.1 gitbook-cli安装 gitbook-cli 是 gitbook 的脚手架工具,帮助我们更方便构建 gitbook 应用,当然也可以直接安装 gitbook ,只不过那样的话,略显麻烦,不推荐. mac 上执行 $ sudo npm install -g gitbook-cli window 上执行 $sudo npm install -g gitbook-cli 安装成功后会带有 gitbook 命令,现在再次运行下 gitbook -V 查看版本信息. # 打印出 `CLI` 和 `GitBook` 版本信息即可,安装版本可能已经大于 `2.3.2` $ gitbook -V CLI version: 2.3.2 GitBook version: 3.2.3 2.2 安装 GitBook Editor gitbook官方客户端编辑器,支持 windows, mac 和 linux ,主要用于可视化编辑文档,组织文档结构. 下载相应平台的 GitBook Editor,正常安装即可. gitbook 的使用方法大致可以有三种,而 GitBook Editor 编辑器只是其中一种,所以这一步是可选的. 使用 gitbook-cli 脚手架提供的各种命令直接在命令行管理 gitbook,适合一定编程经验的软件从业人员. 使用 GitBook Editor 编辑器管理 gitbook ,适合无任何编程的文学创作者. 使用 gitbook.com 官网在线管理 gitbook ,适合不具备本地开发环境的萌新体验者. 3. gitbook命令 3.1 常用命令 安装 GitBook：npm i gitbook-cli -g 初始化 GitBook 项目：gitbook init 安装 GitBook 依赖：gitbook install 开启 GitBook 服务：gitbook serve //gitbook serve --port 2333 指定端口 打包 GitBook 项目：gitbook build GitBook 命令行查看：gitbook -help GitBook 版本查看：gitbook -V 3.2 目录介绍 当我们执行完 npm i gitbook-cli -g 后，就开始进行gitbook开发，找一个空文件夹，初始化一个 GitBook 项目：gitbook init，目录会生成一个 README.md 内容文件和一个 SUMMARY.md 目录文件如下。 - GitBook - README.md - SUMMARY.md SUMMARY.md [链接](链接地址) 表示跳转链接，即 GitBook 会根据你的 SUMMARY 自动帮你生成左侧菜单栏的目录 README.md 书写文档，在SUMMARY中显示 最后，我们在 终端 输入 gitbook serve 即可开启一个 localhost:4000 的服务，请在浏览器中输入 http://localhost:4000 即可访问服务。 4. 总结 gitbook 基于 node.js 开发环境,因此首先要安装好 nodejs 环境,其次再使用 node.js 提供的 npm 包管理工具来安装 gitbook. 只需运行 sudo npm install -g gitbook-cli 即可安装,接着运行 gitbook -V 查看安装版本信息确认已经安装成功. 至此 gitbook 的必要开发环境已经准备妥当,接下来让我们赶紧体验一下 gitbook 的魅力吧! Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-25 17:31:47 "},"gitbook/Other-library/Markdown_Website/GitBook/plugins.html":{"url":"gitbook/Other-library/Markdown_Website/GitBook/plugins.html","title":"插件","keywords":"","body":"插件 1.book.json 配置 1.1 title 设置书本的标题 \"title\": \"webMrYang的文档库\" 1.2 author 作者的相关信息 \"author\": \"webMrYang\" 1.3 description 本书的简单描述 \"description\": \"前端一些资料\" 1.4 language Gitbook使用的语言, 版本2.6.4中可选的语言如下： en, ar, bn, cs, de, en, es, fa, fi, fr, he, it, ja, ko, no, pl, pt, ro, ru, sv, uk, vi, zh-hans, zh-tw 例如，配置使用简体中文 \"language\": \"zh-hans\" 1.5 links 在左侧导航栏添加链接信息 \"links\" : { \"sidebar\" : { \"Home\" : \"https://www.baidu.com\" } } 1.6 styles 自定义页面样式， 默认情况下各generator对应的css文件 \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } 例如使 标签有下边框， 可以在website.css中设置 h1 , h2{ border-bottom: 1px solid #EFEAEA; } 1.7 plugins 配置使用的插件 \"plugins\": [ \"-search\", \"back-to-top-button\", \"expandable-chapters-small\", \"insert-logo\" ] 其中\"-search\"中的 - 符号代表去除默认自带的插件 Gitbook默认自带有5个插件： highlight： 代码高亮 search： 导航栏查询功能（不支持中文） sharing：右上角分享功能 font-settings：字体设置（最上方的\"A\"符号） livereload：为GitBook实时重新加载 1.8 pluginsConfig 配置插件的属性 例如配置prism的属性： \"prism\": { \"css\": [ \"prismjs/themes/prism-solarizedlight.css\" ], \"lang\": { \"shell\": \"bash\" } }, 2 插件安装 用法：在book.json中添加\"plugins\"和\"pluginConfig\"字段。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-插件名，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） 2.1 back-to-top-button 回到顶部 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-back-to-top-button，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"back-to-top-button\" ] } 效果如下图所示： 2.2 expandable-chapters 导航目录折叠 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-expandable-chapters，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"expandable-chapters\" ] } 2.3 代码复制 2.3.1. code 代码添加行号&复制按钮 为代码块添加行号和复制按钮，复制按钮可关闭 单行代码无行号。 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-chapter-fold，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"code\" ] } 如果想去掉复制按钮，在book.json的插件配置块更新： { \"plugins\" : [ \"code\" ], \"pluginsConfig\": { \"code\": { \"copyButtons\": false } } } 效果如下图所示： 2.3.2. copy-code-button 代码复制按钮 为代码块添加复制的按钮。 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-copy-code-button，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"copy-code-button\" ] } 效果如下图所示： 2.4 search-pro 高级搜索（支持中文） 支持中文搜索, 在使用此插件之前，需要将默认的search和lunr 插件去掉。 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-search-pro，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"-lunr\", \"-search\", \"search-pro\" ] } 2.5 splitter 侧边栏宽度可调节 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-splitter，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"splitter\" ] } 效果如下图所示： 2.6 sharing-plus 多一些分享方式 分享当前页面，比默认的 sharing 插件多了一些分享方式。 npm仓库地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-sharing-plus { \"plugins\": [\"-sharing\", \"sharing-plus\"], \"pluginsConfig\": { \"sharing\": { \"douban\": false, \"facebook\": false, \"google\": true, \"pocket\": false, \"qq\": false, \"qzone\": true, \"twitter\": false, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\",\"twitter\", \"weibo\", \"messenger\",\"qq\", \"qzone\",\"viber\",\"whatsapp\" ] } } } 其中： 为true的代表直接显示在页面顶端，为false的不显示，不写默认为false \"all\"中代表点击分享符号显示出来的 效果如下图所示： 2.7 github 在右上角添加github图标 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-github，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"github\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/zhangjikai\" } } } 效果如下图所示： 2.8 tbfed-pagefooter 页面添加页脚 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-tbfed-pagefooter，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"tbfed-pagefooter\" ], \"pluginsConfig\": { \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy xxxx.com 2017\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } } } 效果如下图所示： 2.9 donate 打赏插件 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-donate，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"donate\" ], \"pluginsConfig\": { \"donate\": { \"wechat\": \"微信收款的二维码URL\", \"alipay\": \"支付宝收款的二维码URL\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" } } } 2.10 theme-comscore 为Table添加样式 npm地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-theme-comscore，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"theme-comscore\" ] } 效果如下图所示： 2.11 prism 为 GitBook 的 Code 添加更好看的样式 prism：为 GitBook 的 Code 添加更好看的样式，使用它的时候记得屏蔽 GitBook 默认的 highlight 插件，即通过 （-highlight 表示，下面出现 - 的插件也一样） npm地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-prism，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"prism\", \"-highlight\" ], \"pluginsConfig\": { \"prism\": { \"css\": [ \"prismjs/themes/prism-solarizedlight.css\" ], \"lang\": { \"shell\": \"bash\" } } } } 2.12 anchor-navigation-ex 生成菜单。 expandable-chapters：自动生成菜单,并跳转顶部 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-anchor-navigation-ex，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"anchor-navigation-ex\" ], \"pluginsConfig\": { \"anchor-navigation-ex\": { \"showLevel\": false } } } 效果如下图所示： 2.13 sectionx 将页面分块显示。 用于将页面分成多个部分，并添加按钮以允许读者控制每个部分的可见性。 GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-sectionx，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"sectionx\" ] } 使用方式 参数 说明 data-title 该部分的标题，它将显示为bootstrap面板的标题（大小为h2）。请注意，您不能使用\"标题中的字符，请\"改用。 data-id 对按钮控制起作用。 data-show 默认表示面板内容是否可见的布尔值。true：默认情况下，面板内容对用户可见，面板标题可以单击。false：默认情况下，面板内容对用户隐藏，面板标题不可点击，只能通过添加自定义按钮查看 data-nopdf 一个布尔值，表示该部分是否将隐藏在pdf导出中。true：面板不会显示在.pdf或.epub中。 data-collapse 一个布尔值，表示默认情况下是否打开（但仍然可见）该部分。true：默认情况下，面板内容对用户可见，但已关闭。false：默认情况下，面板内容对用户隐藏，但已打开（默认设置）。 控制按钮 标签 说明 class 该按钮必须属于类“section”。 target 当按下时，将切换id为target的部分//这里就是用到上面的的data-id show 隐藏目标部分时按钮上的文本。 hide 目标部分可见时按钮上的文本。 example： 内容部分2 内容部分2 2.14 baidu-tongji 添加百度统计。 npm地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-baidu-tongji，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"baidu-tongji\" ], \"pluginsConfig\": { \"baidu-tongji\": { \"token\": \"f3f331c21843f7b950e103f51fbabc60\" } } } 2.15 favicon 更改网站的 favicon.ico。 npm地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-favicon，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"favicon\" ], \"pluginsConfig\": { \"favicon\": { \"shortcut\": \"assets/images/favicon.ico\",//首先，shortcut通常可以被所有可以显示favicon的浏览器读取。 \"bookmark\": \"assets/images/favicon.ico\",//在收藏夹中显示自己的图标 \"appleTouch\": \"assets/images/apple-touch-icon.png\",//是一个类似网站favicon的图标文件，用来在iphone和iPad上创建快捷键时使用 \"appleTouchMore\": { \"120x120\": \"assets/images/apple-touch-icon-120x120.png\", \"180x180\": \"assets/images/apple-touch-icon-180x180.png\" } } } } 2.16 待做项☑。 添加 Todo 功能。默认的 checkbox 会向右偏移 2em，如果不希望偏移，可以在 website.css 里加上下面的代码: GitHub地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-todo，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"todo\" ] } 使用示例： * [ ] write some articles * [x] drink a cup of tea [ ] write some articles [x] drink a cup of tea 2.17 Codeblock显示所包含文件的内容。 使用代码块的格式显示所包含文件的内容. 该文件必须存在。插件提供了一些配置，可以区插件官网查看。如果同时使用 ace 和本插件，本插件要在 ace 插件前面加载。 CodeblockNPM地址 aceNPM地址 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装npm install gitbook-plugin-include-codeblock gitbook-plugin-ace，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） { \"plugins\": [ \"include-codeblock\", 'ace' ], \"pluginsConfig\": { \"include-codeblock\": { \"template\": \"ace\", \"unindent\": \"true\", \"theme\": \"monokai\" } } } 使用示例： Example of code \\[import\\](./test.js) Example of code const arr = { \"plugins\": [ \"include-codeblock\" ], \"pluginsConfig\": { \"include-codeblock\": { \"template\": \"ace\", \"unindent\": \"true\", \"theme\": \"monokai\" } } } 2.18 gitalk 评论插件。 gitalk 利用 github 的开发者接口授权,将讨论区的 issue 变成评论区,和 github 结合的如此紧密,适合用源码托管到 github 这类情况. 我们在需要评论的页面中加入下面代码 var gitalk = new Gitalk({ \"clientID\": \"8c2f22bd64d1ea012ac5\", \"clientSecret\": \"992cdea444e1503ceac91bfd74907b37e590a159\", \"repo\": \"webmryang.github.io\", \"owner\": \"WebMrYang\", \"admin\": [\"WebMrYang\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); 字段意思： 1. `clientID` ：GitHub 开发者设置，客户端连接标识。 2. `clientSecret`：GitHub 开发者设置，客户端秘钥。 3. `repo`：GitHub 仓库名，我们的就是 document-library 啦。 4. `owner`：GitHub 仓库所有者，就是我 GitHub 账户：`LiangJunrong`。 5. `admin`：GitHub 仓库管理者，还是我的 GitHub 账户：`LiangJunrong`。（支持数组，多个管理者） 6. `id`：页面的唯一标识，默认值: `location.href` 7. `distractionFreeMode`：类似 Facebook 评论框的全屏遮罩效果,默认值: `false` [官方配置](https://github.com/gitalk/gitalk#install) GitHub开发授权应用 3 插件 - 参考文献 GitBook 搭建 GitBook插件整理 gitbook 入门教程之实用插件 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-27 15:47:10 "},"gitbook/Other-library/Markdown_Website/GitBook/build.html":{"url":"gitbook/Other-library/Markdown_Website/GitBook/build.html","title":"发布","keywords":"","body":"发布 已经写好项目，就可以进行打包，发布了 HTML:gitbook build [书籍路径] [输出路径] PDF: gitbook pdf ./ ./mybook.pdf epub gitbook epub ./ ./mybook.epub mobi gitbook mobi ./ ./mybook.mobi 然后，部署到 GitHub(教程) 上了。 最后，我们查看下我们的部署页面(地址)： Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-25 17:39:23 "},"gitbook/Other-library/Markdown_Website/GitBook/question.html":{"url":"gitbook/Other-library/Markdown_Website/GitBook/question.html","title":"开发问题记录","keywords":"","body":"GitBook 开发问题记录 1. 在使用 gitbook-cli 初始化后，使用插件后报错 gitbook serve和gitbook build都报错 Error: ENOENT: no such file or directory, stat ‘C:*demo_book_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js’ 原来是一个Bug（Vesion：3.2.3）。 https://github.com/GitbookIO/gitbook/issues/1309 解决办法如下。 1、用户目录下找到以下文件。 .gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js Replace all confirm: true with confirm: false 2、执行gitbook fetch 2.6.7 2. gitbook使用gitalk时报Error: Not Found. 这个是因为配置的gitalk中的repo配置错误，可以配置为你的用户名.github.io Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-25 17:15:17 "},"gitbook/Other-library/Markdown_Website/GitHub/":{"url":"gitbook/Other-library/Markdown_Website/GitHub/","title":"GitHub 发布","keywords":"","body":"GitHub 学习 1. 什么是 GitHub Pages？ GitHub Pages 是一个通过 GitHub 项目/仓库 进行部署的，以 username.github.io 的形式生成用户的托管平台。 通过 GitHub Pages，用户只需要把自己的内容在本地编辑好，然后推送到 GitHub 仓库即可。 2. github pages好处 使用零成本: github pages 集成在 github 中, 直接和代码管理绑定在一起, 随着代码更新自动重新部署, 使用非常方便. 免费: 免费提供 username.github.io 的域名, 免费的静态网站服务器. 无数量限制: github pages 没有使用的数量限制, 每一个 github repository 都可以部署为一个静态网站. 3. 搭建 3.1 新建仓库 打开 GitHub 页面，注册号用户后，新建仓库（New repository），在仓库名（Repository name）中输入 username.github.io，例如 webmryang 的就是：webmryang.github.io，然后点击 Create repository 即可创建一个部署好的环境。(用户名大小生成网址时都是小写) 3.2 Clone 项目 clone项目到本地： 下载的时候选择ssh下载，可以配置ssh免密登录 3.3 上传项目到 GitHub 在项目中加入一个html页面执行一下操作： ``` git add . git commit -m 'github' git push ``` 3.4 打开 用户名.github.io 打开 用户名.github.io 3.5 查看Settings 在settings中也可以查看项目在网站上的真实的网址 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-26 15:56:01 "},"gitbook/Other-library/SSH/":{"url":"gitbook/Other-library/SSH/","title":"SSH","keywords":"","body":"SSH 1. 概念 SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括、Linux以及其他平台，都可运行SSH。 2. 安全验证 SSH验证：从客户端来看，SSH提供两种级别的安全验证。 第一种级别（基于口令的安全验证） 只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。 第二种级别（基于密匙的安全验证） 需要依靠密匙，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。 用这种方式，你必须知道自己密匙的口令。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。 3. 命令 3.1 查看当前电脑所有的ssh:ls -al ~/.ssh 3.2 一台电脑上github和gitlab配置ssh 如果没有生成过.ssh文件，就要执行 $ ssh-keygen -t rsa -C \"email@email.com\" 来创建.ssh，如果当前是为github生成，使用github的邮箱，如果是gitlab则输入gitlab的邮箱; 下面你会看到下图，如果只是配置一个github或者gitlab 直接回车就可以了，如果是想同时配置则需要修改生成的id_rsa，以上面为例子，可以输入 /c/Users/Administrator/.ssh/github_id_rsa 后回车,这里的github_id_rsa你可以自己去定义 接下来直接回车就ssh的秘钥就生成了 如果是自己输入了秘钥名称则需要配置一个config文件,里面配置如下(其中.ssh目录如下) # gitlab Host gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id-rsa # github Host github.com HostName github.com # User WebMrYang PreferredAuthentications publickey IdentityFile ~/.ssh/github_id_rsa 当完成以上的ssh秘钥生成后，我们就可以给github或者gitlab来配置公钥了，公钥的后缀是.pub,复制.pub文件中的公钥，登陆你的github帐户。点击你的头像，然后 Settings -> 左栏点击 SSH and GPG keys -> 点击 New SSH key新建公钥title可以随便输key就是你刚刚新建的公钥 可以测试下 ssh git@github.com如果输出Hi xxx! You've successfully authenticated, but GitHub does not # provide shell access. Connection to github.com closed.说明成功了如图： Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-26 18:14:12 "},"gitbook/Other-library/garbageCollection.html":{"url":"gitbook/Other-library/garbageCollection.html","title":"垃圾回收","keywords":"","body":"Chrome 浏览器垃圾回收机制与内存泄漏分析 通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。 手动回收策略，何时分配内存、何时销毁内存都是由代码控制的。 自动回收策略，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。 一、 JavaScript 中调用栈中的数据回收 JavaScript 引擎会通过向下移动 ESP(记录当前执行状态的指针) 来销毁该函数保存在栈中的执行上下文。 二、 JavaScript 堆中的数据回收 在 V8 中会把堆分为 新生代 和 老生代 两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。 新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。 副垃圾回收器，主要负责新生代的垃圾回收。 主垃圾回收器，主要负责老生代的垃圾回收。 不论什么类型的垃圾回收器，它们都有一套共同的执行流程。 第一步标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。 第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。 第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片，。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片。(这步其实是可选的，因为有的垃圾回收器不会产生内存碎片). 2.1 新生代中垃圾回收 新生代中用 Scavenge 算法 来处理，把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。 在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种 角色翻转的操作还能让新生代中的这两块区域无限重复使用下去. 为了执行效率，一般新生区的空间会被设置得比较小,也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了 对象晋升策略,也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。 2.2 老生代中的垃圾回收 老生代中用 标记 - 清除（Mark-Sweep）的算法 来处理。首先是标记过程阶段，标记阶段就是从一组根元素开始，递归遍历这组根元素(遍历调用栈)，在这个遍历过程中，能到达的元素称为 活动对象 ,没有到达的元素就可以判断为 垃圾数据.然后在遍历过程中标记，标记完成后就进行清除过程。它和副垃圾回收器的垃圾清除过程完全不同，这个的清除过程是删除标记数据。 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了 标记 - 整理（Mark-Compact）算法 ，这个标记过程仍然与 标记 - 清除算法 里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，从而让存活对象占用连续的内存块 2.3 全停顿 由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做 全停顿 。 在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果执行垃圾回收的过程中，占用主线程时间过久，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在垃圾回收过程中无法执行，这将会造成页面的卡顿现象。 为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为 增量标记（Incremental Marking）算法. 使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。 三、 内存泄漏 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。 内存泄漏发生的原因 3.1 缓存 有时候为了方便数据的快捷复用，我们会使用缓存,但是缓存必须有一个大小上限才有用。高内存消耗将会导致缓存突破上限，因为缓存内容无法被回收。 3.2 计时器中引用没有清除 当浏览器队列消费不及时时，会导致一些作用域变量得不到及时的释放，因而导致内存泄漏。 var someData = getData(); setInterval(function() { var node = document.getElementById('Node'); if(node) { node.innerHTML = JSON.stringify(someData)); } }, 1000); 这里定义了一个计时器，每隔1s把一些数据写到Node节点里面。但是当这个Node节点被删除后，这里的逻辑其实都不需要了，可是这样写，却导致了计时器里面的回调函数无法被回收，同时，someData里的数据也是无法被回收的。 3.3 全局变量 除了常规设置了比较大的对象在全局变量中，还可能是意外导致的全局变量，如： function foo(arg) { bar = \"this is a hidden global variable\"; } 3.4 闭包 var theThing = null;var replaceThing = function () { var originalThing = theThing; var unused = function () { if (originalThing) console.log(\"hi\"); }; theThing = { longStr: new Array(1000000).join('*'), someMethod: function () { console.log(someMessage); } }; }; setInterval(replaceThing, 1000); 四、 内存泄漏的识别方法 4.1 使用 Chrome 任务管理器实时监视内存使用 打开 chrome 浏览器点击右上角主菜单，选择 更多工具->任务管理器 ，这样就开启了任务管理器面板，然后再右键点击任务管理器的表格标题并启用 JavaScript使用的内存，能看到这样的面板： 下面两列可以告诉您与页面的内存使用有关的不同信息： 内存占用空间(Memory) 列表示原生内存。DOM 节点存储在原生内存中。如果此值正在增大，则说明正在创建 DOM 节点。 JavaScript使用的内存(JavaScript Memory) 列表示 JS 堆。此列包含两个值。您感兴趣的值是实时数字（括号中的数字）。实时数字表示您的页面上的可到达对象正在使用的内存量。如果此数字在增大，要么是正在创建新对象，要么是现有对象正在增长。 当你页面稳定下来之后，这两个的值还在上涨，你就可以查一查是否内存泄漏了。 4.2 利用chrome 时间轴记录可视化内存泄漏 Performance(时间轴) 能够面板直观实时显示JS内存使用情况、节点数量、监听器数量等。 打开 chrome 浏览器，调出调试面板(DevTools),点击Performance选项(低版本是Timeline)，勾选Memory复选框。一种比较好的做法是使用强制垃圾回收开始和结束记录。在记录时点击 Collect garbage 按钮 (强制垃圾回收按钮) 可以强制进行垃圾回收。所以录制顺序可以这样：开始录制前先点击垃圾回收-->点击开始录制-->点击垃圾回收-->点击结束录制。 五、 避免内存泄漏的方法 少用全局变量，避免意外产生全局变量 使用闭包要及时注意，有Dom元素的引用要及时清理。 计时器里的回调没用的时候要记得销毁。 为了避免疏忽导致的遗忘，我们可以使用 WeakSet 和 WeakMap结构，它们对于值的引用都是不计入垃圾回收机制的，表示这是弱引用。举个例子 const wm = new WeakMap();const element = document.getElementById('example'); wm.set(element, 'some information'); wm.get(element) // \"some information\" 这种情况下，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 16:00:55 "},"gitbook/Other-library/Interview/":{"url":"gitbook/Other-library/Interview/","title":"面试","keywords":"","body":"1. 谈谈你对前端性能优化的理解 对数据进行异步加载 开启GZip，精简JavaScript，移除重复脚本，图像优化，将icon做成字体 使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 1. html部分 要避免代码的深层级嵌套。因为层级越深的节点在初始化时更占内存。 尽量不要使用h5摒弃的iframe标签，因为在页面加载的时候iframe标签会阻塞父文档onload事件的触发，这恰恰影响了初始化UI 诸如img、link、script等元素的src或href属性的值不为空，因为就算我们写为src=\"\"浏览器仍会发送http请求 为页面中的图片设置宽高，这样做的好处是在页面加载完前就完成了布局，如若未指定宽高，在图片加载后还要调整其大小，影响时间。 在html文档开始就指定文档字符集，这样做的目的是在有助于浏览器加载时就能立即解析html代码 2. css部分： 将样式表置顶，这样做的好处是文档加载完毕之前样式就已经加载完，不用等页面加载完毕后再重新加载样式 避免使用css表达式，避免重定向 使用外部css并且精简css，移除无用的css样式 用link来代替@important 3. js部分 将脚本置底，避免script标签加载的时候页面等待加载 使用外部脚本以及精简后的去除重复的脚本 尽量减少dom访问，在《高性能JavaScript》中这么比喻：“把DOM看成一个岛屿，把JavaScript(ECMAScript)看成另一个岛屿，两者之间以一座收费桥连接”。所以每次访问DOM都会教一个过桥费，而访问的次数越多，交的费用也就越多。所以一般建议尽量减少过桥次数。 使用json格式来进行数据交换，因为JSON是一种轻量级的数据交换格式，采用完全独立于语言的文本格式，是理想的数据交换格式。同时，JSON是 JavaScript原生格式，这意味着在 JavaScript 中处理 JSON数据不需要任何特殊的 API 或工具包。 2. 网站重构的理解 重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化，针对于SEO进行优化 减少代码间的耦合，让代码保持弹性 压缩或合并或拆分JS、CSS、image等前端资源 3. 对前端界面工程师这个职位是怎么样理解的？ 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术 3. 平时如何管理你的项目？ a. 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； b. 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； c. 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； d. 页面进行标注（例如 页面 模块 开始和结束）； e. CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； f. JS 分文件夹存放 命名以该JS功能为准的英文翻译。 g. 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 20.如何管理前端团队? 请自行根据自己情况做回答，这个没有标准答案。 21.最近在学什么？能谈谈你未来3，5年给自己的规划吗？ 请自行根据自己情况做回答，这个没有标准答案。 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 11:39:34 "},"gitbook/Other-library/Interview/CSS/":{"url":"gitbook/Other-library/Interview/CSS/","title":"CSS","keywords":"","body":"1. 请简述盒模型 IE6盒子模型与W3C盒子模型。 文档中的每个元素被描绘为矩形盒子。盒子有四个边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。 CSS3中有个box-sizing属性可以控制盒子的计算方式， content-box：padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和。（W3C盒子模型） border-box：padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值。（IE6盒子模型） 2. 边距重叠解决方案(BFC) 首先要明确BFC是什么意思，其全英文拼写为 Block Formatting Context 直译为“块级格式化上下文” 1. BFC的原理 内部的box会在垂直方向，一个接一个的放置 每个元素的margin box的左边，与包含块border box的左边相接触（对于从做往右的格式化，否则相反） box垂直方向的距离由margin决定，属于同一个BFC的两个相邻box的margin会发生重叠 BFC的区域不会与浮动区域的box重叠 BFC是一个页面上的独立的容器，外面的元素不会影响BFC里的元素，反过来，里面的也不会影响外面的 计算BFC高度的时候，浮动元素也会参与计算 2. 怎么取创建BFC float属性不为none（脱离文档流） position为absolute或fixed display为inline-block,table-cell,table-caption,flex,inine-flex overflow不为visible 根元素 3. 应用场景 自适应两栏布局 清除内部浮动 防止垂直margin重叠 *{ margin:0; padding:0; } .top{ background: #0ff; height:100px; margin-bottom:30px; } .bottom{ height:100px; margin-top:50px; background: #ddd; } 上 margin-bottom:30px; 下 margin-top:50px; 上 margin-bottom:30px; 下 margin-top:50px; Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 10:32:12 "},"gitbook/Other-library/Interview/JS/":{"url":"gitbook/Other-library/Interview/JS/","title":"JS","keywords":"","body":"1. Cookies，Web Storage(LocalStorage,SessionStorage) Cookies：浏览器均支持，容量为4KB;Web Storage：HTML5，容量为5M Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookie Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，在每次请求一个新的页面的时候都会被发送过去；而Web Storage仅仅是为了在本地“存储”数据而生 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，是会话级别的存储；localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 每个特定的域名下最多生成的cookie个数（IE6：20;IE6以后50；chrome和Safari没有做硬性限制）有限制；IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。 可以使用HttpOnly提升Cookie安全性。httponly 不支持读写，浏览器不允许脚本操作document.cookie去更改cookie，一般情况下都应该设置这个为true，这样可以避免被XSS攻击拿到cookie 2. undefined，null 和 undeclared 有什么区别 null表示\"没有对象\"，即该处不应该有值，转为数值时为0。典型用法是： 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。 undefined表示\"缺少值\"，就是此处应该有一个值，但是还没有定义，转为数值时为NaN。典型用法是： 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined。 undeclared：js语法错误，没有申明直接使用，js无法找到对应的上下文。 2. 使用哪些工具来测试代码的性能 JSPerf, Dromaeo 3. 一次js请求一般情况下有哪些地方会有缓存处理？ DNS缓存：短时间内多次访问某个网站，在限定时间内，不用多次访问DNS服务器。 CDN缓存：内容分发网络（人们可以在就近的代售点取火车票了，不用非得到火车站去排队） 浏览器缓存：浏览器在用户磁盘上，对最新请求过的文档进行了存储。 服务器缓存：将需要频繁访问的Web页面和对象保存在离用户更近的系统中，当再次访问这些对象的时候加快了速度。 4. AMD和CMD 规范的区别？ 查看 AMD 提前执行依赖 - 尽早执行，requireJS 是它的实现。 CMD 按需执行依赖 - 懒执行，seaJS 是它的实现 5. JavaScript 的同源策略 同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。 指一段脚本只能读取来自同一来源的窗口和文档的属性。 6. WEB应用从服务器主动推送Data到客户端有那些方式？ html5 websoket WebSocket 通过 Flash XHR长时间连接 CORS 不可见的Iframe Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-09 09:32:47 "},"gitbook/Other-library/Interview/HTTP/":{"url":"gitbook/Other-library/Interview/HTTP/","title":"HTTP","keywords":"","body":"1. 讲讲输入完网址按下回车，到看到网页这个过程中发生了什么 用户输入url地址，浏览器根据域名寻找IP地址 浏览器向服务器发送http请求，如果服务器段返回以301之类的重定向，浏览器根据相应头中的location再次发送请求 服务器端接受请求，获取html代码，返回给浏览器，这时的html页面代码可能是经过压缩的 浏览器接收服务器响应结果，如果有压缩则首先进行解压处理，紧接着就是页面解析渲染 DNS 解析->TCP 连接->HTTP 请求抛出->服务端处理请求，HTTP 响应返回->浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户 解析渲染该过程主要分为以下步骤： 解析HTML 构建DOM树 DOM树与CSS样式进行附着构造呈现树 布局 绘制 Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 09:37:51 "},"gitbook/Other-library/Interview/Vue/":{"url":"gitbook/Other-library/Interview/Vue/","title":"Vue","keywords":"","body":"Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 08:59:17 "},"gitbook/Other-library/Interview/React/":{"url":"gitbook/Other-library/Interview/React/","title":"React","keywords":"","body":"Copyright © webMrYang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 08:59:22 "}}